Project Structure Overview:
ZXReader/
    Combine.py
    setup.py
    .git/
        hooks/
        info/
        logs/
            refs/
                heads/
                remotes/
                    origin/
        objects/
            00/
            01/
            02/
            03/
            04/
            05/
            07/
            08/
            09/
            0a/
            0b/
            0c/
            0d/
            0e/
            0f/
            11/
            12/
            13/
            14/
            15/
            16/
            17/
            18/
            1b/
            1c/
            1d/
            1e/
            20/
            22/
            23/
            24/
            25/
            26/
            28/
            29/
            2a/
            2b/
            2c/
            2d/
            2e/
            30/
            31/
            32/
            34/
            35/
            36/
            37/
            38/
            39/
            3a/
            3b/
            3c/
            3d/
            3e/
            40/
            42/
            44/
            45/
            46/
            47/
            48/
            49/
            4c/
            4d/
            4e/
            50/
            52/
            53/
            54/
            56/
            57/
            58/
            59/
            5a/
            5b/
            5c/
            5d/
            5e/
            5f/
            60/
            61/
            62/
            63/
            64/
            65/
            66/
            67/
            6a/
            6b/
            6d/
            70/
            71/
            72/
            73/
            74/
            75/
            76/
            78/
            79/
            7a/
            7c/
            7e/
            7f/
            80/
            81/
            82/
            83/
            84/
            85/
            86/
            87/
            88/
            89/
            8a/
            8c/
            8d/
            8e/
            8f/
            91/
            93/
            95/
            96/
            97/
            98/
            99/
            9a/
            9b/
            9d/
            9e/
            9f/
            a0/
            a2/
            a4/
            a6/
            a7/
            a9/
            aa/
            ab/
            ac/
            ae/
            af/
            b0/
            b2/
            b3/
            b4/
            b5/
            b9/
            bb/
            be/
            bf/
            c0/
            c1/
            c3/
            c4/
            c5/
            c7/
            c8/
            c9/
            ca/
            cb/
            cc/
            cd/
            cf/
            d1/
            d3/
            d4/
            d5/
            d6/
            d7/
            d8/
            db/
            dc/
            dd/
            de/
            df/
            e0/
            e2/
            e5/
            e6/
            e7/
            e8/
            e9/
            ea/
            eb/
            ec/
            ed/
            ee/
            ef/
            f1/
            f2/
            f3/
            f4/
            f5/
            f6/
            f7/
            f8/
            fc/
            fd/
            ff/
            info/
            pack/
        refs/
            heads/
            remotes/
                origin/
            tags/
    dictionaries/
    fonts/
        Montserrat/
            static/
        Noto_Sans_SC/
            static/
        Noto_Sans_TC/
            static/
        Open_Sans/
            static/
        Roboto/
    src/
        detect_chapters_methods.py
        main.py
        test_text_processing.py
        core/
            chapter_manager.py
            detect_chapters_methods.py
            dictionary_manager.py
            file_handler.py
            translation_manager.py
        gui/
            chapter_panel.py
            dictionary_panel.py
            file_info_panel.py
            font_manager.py
            main_translation_panel.py
            main_window.py
            menu_bar.py
            style_manager.py
        QTEngine/
            config.py
            QTEngine.py
            __init__.py
            data/
            models/
                chinese_converter.py
                trie.py
            src/
                character_utils.py
                data_loader.py
                data_watcher.py
                performance.py
                ReplaceChar.py
                text_processing.py
                translation_engine.py
                __init__.py
        utils/
            qt_utils.py
    WSDev_docs/




# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\Combine.py
# ========================================

import os
import re

# Directories to exclude
EXCLUDE_DIRS = {'.venv', '__pycache__', 'build', 'caches'}

# File extensions to include
INCLUDE_EXTENSIONS = {'.py','yaml'}

# Patterns to sanitize sensitive data
SENSITIVE_PATTERNS = [
    re.compile(r'(?i)(password\s*=\s*["\'])([^"\']+)(["\'])'),
    re.compile(r'(?i)(api_key\s*=\s*["\'])([^"\']+)(["\'])'),
    re.compile(r'(?i)(secret\s*=\s*["\'])([^"\']+)(["\'])')
]

def sanitize_content(content):
    """Sanitize sensitive data in the content."""
    for pattern in SENSITIVE_PATTERNS:
        content = pattern.sub(r'\1<REDACTED>\3', content)
    return content

def is_excluded_dir(dir_name):
    """Check if a directory should be excluded."""
    return dir_name in EXCLUDE_DIRS

def combine_source_code(project_dir, output_file):
    """Combine source code into a single file."""
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Write project structure overview
        outfile.write("Project Structure Overview:\n")
        for root, dirs, files in os.walk(project_dir):
            # Filter out excluded directories
            dirs[:] = [d for d in dirs if not is_excluded_dir(d)]
            # Write directory structure
            level = root.replace(project_dir, '').count(os.sep)
            indent = ' ' * 4 * level
            outfile.write(f"{indent}{os.path.basename(root)}/\n")
            sub_indent = ' ' * 4 * (level + 1)
            for f in files:
                if any(f.endswith(ext) for ext in INCLUDE_EXTENSIONS):
                    outfile.write(f"{sub_indent}{f}\n")
        outfile.write("\n\n")

        # Combine files
        for root, dirs, files in os.walk(project_dir):
            # Filter out excluded directories
            dirs[:] = [d for d in dirs if not is_excluded_dir(d)]
            for file in files:
                if any(file.endswith(ext) for ext in INCLUDE_EXTENSIONS):
                    file_path = os.path.join(root, file)
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        # Write file separator
                        outfile.write(f"\n\n# {'=' * 40}\n")
                        outfile.write(f"# File: {file_path}\n")
                        outfile.write(f"# {'=' * 40}\n\n")
                        # Read and sanitize content
                        content = infile.read()
                        sanitized_content = sanitize_content(content)
                        outfile.write(sanitized_content)

if __name__ == '__main__':
    project_directory = r'C:\Users\Zhu Xian\source\repos\ZXReader'# Replace with your project directory
    output_filename = 'combined_code.txt'
    combine_source_code(project_directory, output_filename)
    print(f"Combined source code saved to {output_filename}")

# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\setup.py
# ========================================



# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\detect_chapters_methods.py
# ========================================

import regex as re
from typing import List, Tuple, Optional

CHAPTER_MATCHERS = {
    "Mục lục ( Đi trống không )": r"(?<=[　\s])(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|集(?![合和]))).{0,30}$",
    "Mục lục": r"^[ 　\t]{0,4}(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|集(?![合和])|部(?![分赛游])|篇(?!张))).{0,30}$",
    "Mục lục ( Phối hợp giới thiệu vắn tắt )": r"(?<=[　\s])(?:(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|集(?![合和])|部(?![分赛游])|回(?![合来事去])|场(?![和合比电是])|篇(?!张))).{0,30}$",
    "Mục lục ( Cổ điển, light novel dự bị )": r"^[ 　\t]{0,4}(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|集(?![合和])|部(?![分赛游])|回(?![合来事去])|场(?![和合比电是])|话|篇(?!张))).{0,30}$",
    "Con số ( Thuần con số tiêu đề )": r"(?<=[　\s])\d+\.?[ 　\t]{0,4}$",
    "Viết kép con số ( Thuần con số tiêu đề )": r"(?<=[　\s])[零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,12}[ 　\t]{0,4}$",
    "Con số phối hợp ( Thuần con số tiêu đề )": r"(?<=[　\s])[零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟\d]{1,12}[ 　\t]{0,4}$",
    "Con số Ngăn cách phù Tiêu đề tên": r"^[ 　\t]{0,4}\d{1,5}[:：,.， 、_—\-].{1,30}$",
    "Viết kép con số Ngăn cách phù Tiêu đề tên": r"^[ 　\t]{0,4}(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|[零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章?)[ 、_—\-].{1,30}$",
    "Con số phối hợp Ngăn cách phù Tiêu đề tên": r"^[ 　\t]{0,4}(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|[零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章?[ 、_—\-]|\d{1,5}章?[:：,.， 、_—\-]).{0,30}$",
    "Tiêu đề / số thứ tự": r"^[ 　\t]{0,4}正文[ 　]{1,4}.{0,20}$",
    "Chapter/Section/Part/Episode số thứ tự Tiêu đề": r"^[ 　\t]{0,4}(?:[Cc]hapter|[Ss]ection|[Pp]art|ＰＡＲＴ|[Nn][oO][.、]|[Ee]pisode|(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外)\s{0,4}\d{1,4}.{0,30}$",
    "Chapter( Đi giới thiệu vắn tắt )": r"^[ 　\t]{0,4}(?:[Cc]hapter|[Ss]ection|[Pp]art|ＰＡＲＴ|[Nn][Oo]\.|[Ee]pisode)\s{0,4}\d{1,4}.{0,30}$",
    "Ký hiệu đặc thù Số thứ tự Tiêu đề": r"(?<=[\s　])[【〔〖「『〈［\[](?:第|[Cc]hapter)[\d零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,10}[章节].{0,20}$",
    "Ký hiệu đặc thù Tiêu đề ( Thành đôi )": r"(?<=[\s　]{0,4})(?:[\[〈「『〖〔《（【\(].{1,30}[\)】）》〕〗』」〉\]]?|(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外)[ 　]{0,4}$",
    "Ký hiệu đặc thù Tiêu đề ( Một cái )": r"(?<=[\s　]{0,4})(?:[☆★✦✧].{1,30}|(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外)[ 　]{0,4}$",
    "Chương / cuốn Số thứ tự Tiêu đề": r"^[ \t　]{0,4}(?:(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|[卷章][\d零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8})[ 　]{0,4}.{0,30}$",
    "Trên cùng tiêu đề": r"^\S.{1,20}$",
    "Song tiêu đề ( Phía trước hướng )": r"(?m)(?<=[ \t　]{0,4})第[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章.{0,30}$(?=[\s　]{0,8}第[\d零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章)",
    "Song tiêu đề ( Sau hướng )": r"(?m)(?<=[ \t　]{0,4}第[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章.{0,30}$[\s　]{0,8})第[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章.{0,30}$",
    "Tên sách Dấu móc Số thứ tự": r"^.{1,20}[(（][\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}[)）][ 　\t]{0,4}$",
    "Tên sách Số thứ tự": r"^.{1,20}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}[ 　\t]{0,4}$",
    "Đặc biệt ký tự Tiêu đề Đặc biệt ký hiệu": r"(?<=\={3,6}).{1,40}?(?=\=)",
    "Số lượng từ chia cắt Phân khúc đọc": r"(?<=[ 　\t]{0,4})(?:.{0,15}分[页节章段]阅读[-_ ]|第\s{0,4}[\d零一二两三四五六七八九十百千万]{1,6}\s{0,4}[页节]).{0,30}$",
    "Thông dụng quy tắc": r"(?im)^.{0,6}(?:[引楔]子|正文(?!完|结)|[引序前]言|[序终]章|扉页|[上中下][部篇卷]|卷首语|后记|尾声|番外|={2,4}|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|页[、 　]|集(?![合和])|部(?![分是门落])|篇(?!张))).{0,40}$|^.{0,6}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟a-z]{1,8}[、. 　].{0,20}$",
}

def detect_chapters(text: str, method: Optional[str] = None) -> List[Tuple[int, int]]:
    """Detect chapter positions in text using the specified method"""
    if not text:
        return []
    
    # Use first method if none specified
    pattern = CHAPTER_MATCHERS[method if method in CHAPTER_MATCHERS else list(CHAPTER_MATCHERS.keys())[0]]
    chapters = []
    
    for match in re.finditer(pattern, text, re.MULTILINE):
        start = match.start()
        end = match.end()
        chapters.append((start, end))
    
    return chapters if chapters else []

# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\main.py
# ========================================

import sys
import os
src_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.append(src_path)
from src.gui.main_window import MainWindow
from src.core.translation_manager import TranslationManager
from src.core.dictionary_manager import DictionaryManager
from src.core.chapter_manager import ChapterManager
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.append(os.path.abspath(os.path.dirname(__file__)))
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
current_dir = os.path.dirname(os.path.abspath(__file__))
qt_engine_path = os.path.join(current_dir, 'QTEngine')
sys.path.append(qt_engine_path)
from PyQt5.QtWidgets import QApplication
from src.QTEngine.QTEngine import QTEngine
 

if __name__ == '__main__':
    app = QApplication(sys.argv)
    qt_engine = QTEngine()
    translation_manager = TranslationManager()
    dictionary_manager = DictionaryManager()
    chapter_manager = ChapterManager(qt_engine)
    main_window = MainWindow(translation_manager, dictionary_manager, chapter_manager)
    main_window.show()
    sys.exit(app.exec_())


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\test_text_processing.py
# ========================================

import sys
import os

# Add necessary paths
src_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.append(src_path)

from QTEngine.src.text_processing import convert_to_sino_vietnamese, process_paragraph
from QTEngine.src.data_loader import DataLoader

def test_mapping():
    # Test text
    test_text = """001 0分狂魔
千叶市公立小学，一年级a班。
千叶市公立小学，一年级a班。
千叶市公立小学，一年级a班。
年轻的大姐姐老师站在上面，手捧一摞试卷，面带微笑看着下方的孩子们......
她的心情很好，因为在这些孩子们中，有个段位明显高于平均水平的小学生，能够教导这样的学生，老师很自豪。
“测验成绩出来了哦，这次大家都考得不错，”大姐姐老师面带微笑，满面红光，“在这里要特意表扬一下雪之下，100分，大家鼓掌——”
“真厉害呢雪乃酱，又是满分，来拿你的试卷吧。”
随着掌声，教室里孩子们目光整齐划一看向那个默默起身的小萝莉，脸庞娇艳清丽、黑发飘飘，还是个七岁的小女孩就展现出自己的美貌与魅力，就是神色有点淡定，仿佛拿到一百分是再简单不过的事情。
无形中装了个逼啊。
角落里的野比大雄单手托腮，无聊的把玩手中铅笔，默默听着周围同学们的窃窃私语。
“又是100分，好厉害。”
“好像每次考试她都是100分吧？”
"""
    
    # Load data using DataLoader
    data_loader = DataLoader()
    names2, names, viet_phrase, chinese_phien_am, loading_info = data_loader.load_data()

    # Test paragraph processing
    result, mapping = process_paragraph(test_text, names2, names, viet_phrase, chinese_phien_am)
    
    # Print original and translated text with mapping information
    sys.stdout.buffer.write(("Original Text:\n" + test_text + "\n").encode('utf-8'))
    sys.stdout.buffer.write(("Translated Text:\n" + result + "\n").encode('utf-8'))
    sys.stdout.buffer.write("Mapping Information:\n".encode('utf-8'))
    for block in mapping.blocks:
        sys.stdout.buffer.write((f"Original: '{block.original}' ({block.orig_start}-{block.orig_end})\n").encode('utf-8'))
        sys.stdout.buffer.write((f"Translated: '{block.translated}' ({block.trans_start}-{block.trans_end})\n").encode('utf-8'))
        sys.stdout.buffer.write(("-" * 50 + "\n").encode('utf-8'))
    
    # Prepare to save mapping information
    mapping_info = []
    for block in mapping.blocks:
        mapping_info.append(f"Original: '{block.original}' ({block.orig_start}-{block.orig_end})\n")
        mapping_info.append(f"Translated: '{block.translated}' ({block.trans_start}-{block.trans_end})\n")
        mapping_info.append("--------------------------------------------------\n")

    # Save output to markdown file
    with open('test_results.md', 'w', encoding='utf-8') as f:
        f.write('# Test Results\n')
        f.write('## Test Mapping Result\n')
        f.write(f'\n{result}\n')
        f.write('## Mapping Information\n')
        f.writelines(mapping_info)
    return result

if __name__ == "__main__":
    result = test_mapping()

# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\core\chapter_manager.py
# ========================================

from typing import List, Tuple, Optional
from src.detect_chapters_methods import detect_chapters, CHAPTER_MATCHERS
from src.QTEngine.QTEngine import QTEngine
 
class ChapterManager:
    def __init__(self, qt_engine: QTEngine):
        self.qt_engine = qt_engine
        self.chapters: List[Tuple[int, int]] = []
        self.chapter_titles: List[str] = []
        self.translated_chapter_titles: List[str] = []
        self.current_chapter_index: int = -1
        self.text: str = ""
        self._detection_method: str = list(CHAPTER_MATCHERS.keys())[0]  # Default to first method
 
    def set_text(self, text: str) -> None:
        self.text = text
        self.detect_and_set_chapters()
 
    def detect_and_set_chapters(self) -> None:
        self.chapters = detect_chapters(self.text, self._detection_method)
        self.chapter_titles = self._extract_chapter_titles()
        self._translate_chapter_titles()
        self.current_chapter_index = 0
 
    def _extract_chapter_titles(self) -> List[str]:
        titles = []
        for start, end in self.chapters:
            titles.append(self.text[start:end])
        return titles
 
    def _translate_chapter_titles(self) -> None:
        translated_titles = []
        for title in self.chapter_titles:
            translated_title = self.qt_engine.translate(title)
            translated_titles.append(translated_title)
        self.translated_chapter_titles = translated_titles
 
    def get_chapter_titles(self) -> List[str]:
        return self.translated_chapter_titles
 
    def get_chapters(self) -> List[str]:
        """Get list of chapter titles"""
        return self.translated_chapter_titles
 
    def get_chapter_text(self, index: int) -> str:
        if not self.chapters:
            return ""
        if index == -1:
            return self.text
        if index < 0 or index >= len(self.chapters):
            return ""
        start, end = self.chapters[index]
        
        # Handle edge case where the last chapter goes to the end of the text
        if index == len(self.chapters) - 1:
            return self.text[start:]
        else:
            next_start, _ = self.chapters[index+1]
            return self.text[start:next_start]
 
    def next_chapter(self) -> int:
        if self.current_chapter_index < len(self.chapters) - 1:
            self.current_chapter_index += 1
        return self.current_chapter_index
 
    def prev_chapter(self) -> int:
        if self.current_chapter_index > 0:
            self.current_chapter_index -= 1
        return self.current_chapter_index
 
    def set_current_chapter(self, index: int) -> int:
        if 0 <= index < len(self.chapters):
            self.current_chapter_index = index
        return self.current_chapter_index
    
    def get_current_chapter_index(self) -> int:
        return self.current_chapter_index
 
    @property
    def detection_methods(self) -> List[str]:
        """Get available chapter detection methods"""
        return list(CHAPTER_MATCHERS.keys())
 
    def set_detection_method(self, method: str) -> None:
        """Set the chapter detection method"""
        if method in CHAPTER_MATCHERS:
            self._detection_method = method
            if self.text:  # Re-detect chapters if we have text
                self.detect_and_set_chapters()


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\core\detect_chapters_methods.py
# ========================================

import regex as re

CHAPTER_MATCHERS = {
    "Mục lục ( Đi trống không )": r"(?<=[　\s])(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|集(?![合和]))).{0,30}$",
    "Mục lục": r"^[ 　\t]{0,4}(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|集(?![合和])|部(?![分赛游])|篇(?!张))).{0,30}$",
    "Mục lục ( Phối hợp giới thiệu vắn tắt )": r"(?<=[　\s])(?:(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|集(?![合和])|部(?![分赛游])|回(?![合来事去])|场(?![和合比电是])|篇(?!张))).{0,30}$",
    "Mục lục ( Cổ điển, light novel dự bị )": r"^[ 　\t]{0,4}(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|集(?![合和])|部(?![分赛游])|回(?![合来事去])|场(?![和合比电是])|话|篇(?!张))).{0,30}$",
    "Con số ( Thuần con số tiêu đề )": r"(?<=[　\s])\d+\.?[ 　\t]{0,4}$",
    "Viết kép con số ( Thuần con số tiêu đề )": r"(?<=[　\s])[零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,12}[ 　\t]{0,4}$",
    "Con số phối hợp ( Thuần con số tiêu đề )": r"(?<=[　\s])[零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟\d]{1,12}[ 　\t]{0,4}$",
    "Con số Ngăn cách phù Tiêu đề tên": r"^[ 　\t]{0,4}\d{1,5}[:：,.， 、_—\-].{1,30}$",
    "Viết kép con số Ngăn cách phù Tiêu đề tên": r"^[ 　\t]{0,4}(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|[零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章?)[ 、_—\-].{1,30}$",
    "Con số phối hợp Ngăn cách phù Tiêu đề tên": r"^[ 　\t]{0,4}(?:序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|[零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章?[ 、_—\-]|\d{1,5}章?[:：,.， 、_—\-]).{0,30}$",
    "Tiêu đề / số thứ tự": r"^[ 　\t]{0,4}正文[ 　]{1,4}.{0,20}$",
    "Chapter/Section/Part/Episode số thứ tự Tiêu đề": r"^[ 　\t]{0,4}(?:[Cc]hapter|[Ss]ection|[Pp]art|ＰＡＲＴ|[Nn][oO][.、]|[Ee]pisode|(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外)\s{0,4}\d{1,4}.{0,30}$",
    "Chapter( Đi giới thiệu vắn tắt )": r"^[ 　\t]{0,4}(?:[Cc]hapter|[Ss]ection|[Pp]art|ＰＡＲＴ|[Nn][Oo]\.|[Ee]pisode)\s{0,4}\d{1,4}.{0,30}$",
    "Ký hiệu đặc thù Số thứ tự Tiêu đề": r"(?<=[\s　])[【〔〖「『〈［\[](?:第|[Cc]hapter)[\d零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,10}[章节].{0,20}$",
    "Ký hiệu đặc thù Tiêu đề ( Thành đôi )": r"(?<=[\s　]{0,4})(?:[\[〈「『〖〔《（【\(].{1,30}[\)】）》〕〗』」〉\]]?|(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外)[ 　]{0,4}$",
    "Ký hiệu đặc thù Tiêu đề ( Một cái )": r"(?<=[\s　]{0,4})(?:[☆★✦✧].{1,30}|(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外)[ 　]{0,4}$",
    "Chương / cuốn Số thứ tự Tiêu đề": r"^[ \t　]{0,4}(?:(?:内容|文章)?简介|文案|前言|序章|楔子|正文(?!完|结)|终章|后记|尾声|番外|[卷章][\d零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8})[ 　]{0,4}.{0,30}$",
    "Trên cùng tiêu đề": r"^\S.{1,20}$",
    "Song tiêu đề ( Phía trước hướng )": r"(?m)(?<=[ \t　]{0,4})第[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章.{0,30}$(?=[\s　]{0,8}第[\d零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章)",
    "Song tiêu đề ( Sau hướng )": r"(?m)(?<=[ \t　]{0,4}第[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章.{0,30}$[\s　]{0,8})第[\d零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}章.{0,30}$",
    "Tên sách Dấu móc Số thứ tự": r"^.{1,20}[(（][\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}[)）][ 　\t]{0,4}$",
    "Tên sách Số thứ tự": r"^.{1,20}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]{1,8}[ 　\t]{0,4}$",
    "Đặc biệt ký tự Tiêu đề Đặc biệt ký hiệu": r"(?<=\={3,6}).{1,40}?(?=\=)",
    "Số lượng từ chia cắt Phân khúc đọc": r"(?<=[ 　\t]{0,4})(?:.{0,15}分[页节章段]阅读[-_ ]|第\s{0,4}[\d零一二两三四五六七八九十百千万]{1,6}\s{0,4}[页节]).{0,30}$",
    "Thông dụng quy tắc": r"(?im)^.{0,6}(?:[引楔]子|正文(?!完|结)|[引序前]言|[序终]章|扉页|[上中下][部篇卷]|卷首语|后记|尾声|番外|={2,4}|第\s{0,4}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟]+?\s{0,4}(?:章|节(?!课)|卷|页[、 　]|集(?![合和])|部(?![分是门落])|篇(?!张))).{0,40}$|^.{0,6}[\d〇零一二两三四五六七八九十百千万壹贰叁肆伍陆柒捌玖拾佰仟a-z]{1,8}[、. 　].{0,20}$",
}

# Make sure this function is defined
def create_pattern_matcher(pattern):
    compiled_pattern = re.compile(pattern, re.MULTILINE | re.VERSION1)
    def matcher(text):
        return [(m.start(), m.group()) for m in compiled_pattern.finditer(text)]
    return matcher

# Create the CHAPTER_MATCHERS dictionary with compiled patterns
CHAPTER_MATCHERS = {name: create_pattern_matcher(pattern) for name, pattern in CHAPTER_MATCHERS.items()}

def detect_chapters(text):
    chapters = []
    for name, matcher in CHAPTER_MATCHERS.items():
        chapters.extend(matcher(text))
    
    # Sort chapters by their position in the text
    chapters.sort(key=lambda x: x[0])
    
    return chapters

# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\core\dictionary_manager.py
# ========================================

import os
from src.QTEngine.models.trie import Trie
from PyQt5.QtWidgets import QFileDialog, QApplication
import sys
from typing import Dict, Optional, List, Tuple

class DictionaryManager:
    # Define the order of dictionaries for display
    DICTIONARY_ORDER = ['Names', 'Names2', 'VietPhrase', 'LacViet', 'ThieuChuu', 'Babylon']

    def __init__(self):
        """Initializes the Dictionary Manager."""
        self.dictionaries = {}
        self.qt_engine_dictionaries = {}  # QTEngine's dictionaries (Names, Names2, VietPhrase)
        self.load_dictionaries()

    def load_dictionaries(self):
        """Loads dictionaries from the dictionaries folder and QTEngine."""
        # Get the project root directory
        current_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(os.path.dirname(current_dir))
        
        # Load external dictionaries
        dictionaries_folder = os.path.join(project_root, 'dictionaries')
        if os.path.exists(dictionaries_folder):
            for filename in os.listdir(dictionaries_folder):
                if filename.endswith('.txt'):
                    filepath = os.path.join(dictionaries_folder, filename)
                    dictionary_name = filename[:-4]  # Remove .txt extension
                    self.dictionaries[dictionary_name] = self.load_dictionary(filepath)

        # Load QTEngine dictionaries
        qt_engine_data_folder = os.path.join(project_root, 'src', 'QTEngine', 'data')
        if os.path.exists(qt_engine_data_folder):
            qt_engine_files = {
                'Names': 'Names.txt',
                'Names2': 'Names2.txt',
                'VietPhrase': 'VietPhrase.txt'
            }
            for dict_name, filename in qt_engine_files.items():
                filepath = os.path.join(qt_engine_data_folder, filename)
                if os.path.exists(filepath):
                    self.qt_engine_dictionaries[dict_name] = self.load_dictionary(filepath)

    def load_dictionary(self, filepath: str) -> Trie:
        """
        Loads a dictionary from a given file.

        Args:
            filepath (str): The path to the dictionary file.

        Returns:
            Trie: A Trie object containing the dictionary data.
        """
        trie = Trie()
        try:
            with open(filepath, 'r', encoding='utf-8-sig') as f:  # Handle UTF-8 BOM
                for line in f:
                    parts = line.strip().split('=', 1)
                    if len(parts) == 2:
                        word, definition = parts
                        # Handle line breaks in definitions (e.g., ThieuChuu, LacViet)
                        definition = definition.replace('\\n', '\n').replace('\t', '    ')
                        trie.insert(word, definition)
        except Exception as e:
            print(f"Error loading dictionary from {filepath}: {e}")
        return trie

    def find_longest_prefix_match(self, text: str, dictionary: Trie) -> Optional[Tuple[str, str]]:
        """
        Find the longest prefix match in a dictionary.

        Args:
            text (str): The text to look up.
            dictionary (Trie): The dictionary to search in.

        Returns:
            Optional[Tuple[str, str]]: A tuple of (matched_text, definition) if found, None otherwise.
        """
        match, definition = dictionary.find_longest_prefix(text)
        if match and definition:
            return match, definition
        return None

    def lookup_word(self, word: str) -> Dict[str, str]:
        """
        Looks up a word in all dictionaries using longest prefix matching.

        Args:
            word (str): The word to look up.

        Returns:
            Dict[str, str]: A dictionary containing definitions from different dictionaries.
        """
        results = {}
        
        # First check QTEngine dictionaries
        for name in ['Names', 'Names2', 'VietPhrase']:
            if name in self.qt_engine_dictionaries:
                match = self.find_longest_prefix_match(word, self.qt_engine_dictionaries[name])
                if match:
                    results[name] = match[1]

        # Then check external dictionaries
        for name in ['LacViet', 'ThieuChuu', 'Babylon']:
            if name in self.dictionaries:
                match = self.find_longest_prefix_match(word, self.dictionaries[name])
                if match:
                    results[name] = match[1]

        return results

    def search_in_definitions(self, query: str) -> Dict[str, List[Tuple[str, str]]]:
        """
        Search for a query string within dictionary definitions.

        Args:
            query (str): The text to search for.

        Returns:
            Dict[str, List[Tuple[str, str]]]: Dictionary name -> list of (word, definition) pairs.
        """
        results = {}
        
        # Search in QTEngine dictionaries
        for name, dictionary in self.qt_engine_dictionaries.items():
            matches = []
            for word in dictionary.get_all_words():
                definition = dictionary.search(word)
                if definition and query.lower() in definition.lower():
                    matches.append((word, definition))
            if matches:
                results[name] = matches

        # Search in external dictionaries
        for name, dictionary in self.dictionaries.items():
            matches = []
            for word in dictionary.get_all_words():
                definition = dictionary.search(word)
                if definition and query.lower() in definition.lower():
                    matches.append((word, definition))
            if matches:
                results[name] = matches

        return results

    def sync_custom_names(self):
        """
        Allows users to load a custom Names2.txt file and sync it with QTEngine's Names2.txt.
        """
        app = QApplication(sys.argv)
        file_path, _ = QFileDialog.getOpenFileName(None, 'Open Custom Names2 File', '', 'Text Files (*.txt);;All Files (*)')
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8-sig') as custom_file:
                    custom_names = custom_file.read()
                
                current_dir = os.path.dirname(os.path.abspath(__file__))
                project_root = os.path.dirname(os.path.dirname(current_dir))
                qt_engine_names2_path = os.path.join(project_root, 'src', 'QTEngine', 'data', 'Names2.txt')

                with open(qt_engine_names2_path, 'w', encoding='utf-8') as qt_engine_file:
                    qt_engine_file.write(custom_names)
                
                print(f"Successfully synced custom Names2.txt with QTEngine's Names2.txt")
                # Reload the dictionaries
                self.load_dictionaries()
            except Exception as e:
                print(f"Error syncing custom Names2.txt: {e}")


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\core\file_handler.py
# ========================================

import os
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QWidget
import chardet

class FileHandler:
    def __init__(self):
        self.parent = QWidget()

    def open_file_dialog(self):
        file_path, _ = QFileDialog.getOpenFileName(self.parent, "Open Text File", "", "Text Files (*.txt);;All Files (*)")
        return file_path

    def read_file(self, file_path):
        try:
            with open(file_path, 'rb') as file:
                raw_data = file.read()
                encoding_result = chardet.detect(raw_data)
                encoding = encoding_result['encoding']
                if encoding:
                    try:
                        content = raw_data.decode(encoding)
                        return content
                    except UnicodeDecodeError:
                        QMessageBox.critical(self.parent, "Error", f"Could not decode file with encoding: {encoding}")
                        return None
                else:
                    QMessageBox.critical(self.parent, "Error", "Could not detect file encoding.")
                    return None
        except Exception as e:
            QMessageBox.critical(self.parent, "Error", f"Could not read file: {e}")
            return None


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\core\translation_manager.py
# ========================================

import os
import sys
from typing import Optional, Tuple

# Assuming QTEngine is in the parent directory of 'core'
current_dir = os.path.dirname(__file__)
qt_engine_path = os.path.abspath(os.path.join(current_dir, '..', 'QTEngine'))
sys.path.append(qt_engine_path)

from QTEngine import QTEngine
from src.QTEngine.src.text_processing import TranslationMapping

class TranslationManager:
    def __init__(self, qt_engine: Optional[QTEngine] = None):
        """
        Initializes the Translation Manager with an optional QTEngine instance.
        
        Args:
            qt_engine (QTEngine, optional): An existing QTEngine instance to use.
                                          If None, creates a new instance.
        """
        self.qt_engine = qt_engine if qt_engine is not None else QTEngine()
        self.current_mapping = None

    def translate_text(self, text: str) -> str:
        """
        Translates the given text using QTEngine.

        Args:
            text (str): The text to be translated.

        Returns:
            str: The translated text.
        """
        if not text:
            return ""
        
        translated_text, mapping = self.qt_engine.translate_with_mapping(text)
        self.current_mapping = mapping
        return translated_text
    
    def get_translated_file_path(self, file_path: str) -> str:
        """
        Generates the translated file path based on the original file path.

        Args:
            file_path (str): The path to the original file.

        Returns:
            str: The translated file path.
        """
        if not file_path:
            return ""
        
        file_name = os.path.basename(file_path)
        file_name_without_extension, file_extension = os.path.splitext(file_name)
        translated_file_name = self.translate_text(file_name_without_extension)
        translated_file_path = os.path.join(os.path.dirname(file_path), f"{translated_file_name}{file_extension}")
        return translated_file_path

    def get_translated_segment(self, original_text: str) -> Optional[Tuple[str, int, int]]:
        """
        Get the translated segment and its position for an original text segment.

        Args:
            original_text (str): The original text segment to look up.

        Returns:
            Optional[Tuple[str, int, int]]: A tuple containing (translated_text, start_pos, end_pos),
                                          or None if no mapping exists.
        """
        if self.current_mapping:
            return self.current_mapping.get_translated_segment(original_text)
        return None

    def get_original_segment(self, translated_text: str) -> Optional[Tuple[str, int, int]]:
        """
        Get the original segment and its position for a translated text segment.

        Args:
            translated_text (str): The translated text segment to look up.

        Returns:
            Optional[Tuple[str, int, int]]: A tuple containing (original_text, start_pos, end_pos),
                                          or None if no mapping exists.
        """
        if self.current_mapping:
            return self.current_mapping.get_original_segment(translated_text)
        return None


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\gui\chapter_panel.py
# ========================================

from PyQt5.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QComboBox,
    QListWidget,
    QPushButton,
    QHBoxLayout,
    QMessageBox
)
from PyQt5.QtCore import pyqtSignal
from typing import Optional
from src.core.chapter_manager import ChapterManager
from src.core.translation_manager import TranslationManager

class ChapterPanel(QWidget):
    chapter_selected = pyqtSignal(int)  # Signal when a chapter is selected
    chapter_changed = pyqtSignal(int)   # Signal when chapter content changes

    def __init__(self, parent: Optional[QWidget], chapter_manager: ChapterManager, translation_manager: TranslationManager):
        super().__init__(parent)
        self.chapter_manager = chapter_manager
        self.translation_manager = translation_manager
        self.initUI()
        self.update_detection_methods()

    def initUI(self):
        layout = QVBoxLayout()

        self.method_dropdown = QComboBox()
        self.method_dropdown.currentIndexChanged.connect(self.update_chapter_list)  # type: ignore
        layout.addWidget(self.method_dropdown)

        self.chapter_list = QListWidget()
        self.chapter_list.itemClicked.connect(self.on_chapter_selected)  # type: ignore
        layout.addWidget(self.chapter_list)

        nav_layout = QHBoxLayout()
        self.prev_button = QPushButton("Previous")
        self.prev_button.clicked.connect(self.prev_chapter)  # type: ignore
        nav_layout.addWidget(self.prev_button)

        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.next_chapter)  # type: ignore
        nav_layout.addWidget(self.next_button)
        layout.addLayout(nav_layout)

        self.setLayout(layout)

    def update_detection_methods(self):
        self.method_dropdown.clear()
        self.method_dropdown.addItems(self.chapter_manager.detection_methods)
        self.method_dropdown.addItem("Hiển thị toàn bộ")

    def update_chapter_list(self):
        selected_method = self.method_dropdown.currentText()
        try:
            self.chapter_manager.set_detection_method(selected_method)
            chapters = self.chapter_manager.get_chapters()
            self.chapter_list.clear()
            if selected_method == "Hiển thị toàn bộ":
                self.chapter_list.addItem("Toàn bộ")
            else:
                for i, chapter in enumerate(chapters):
                    self.chapter_list.addItem(chapter)
                if chapters:
                    self.chapter_list.setCurrentRow(0)
                    self.chapter_selected.emit(0)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not detect chapters: {e}")

    def on_chapter_selected(self, item):
        selected_method = self.method_dropdown.currentText()
        if selected_method == "Hiển thị toàn bộ":
            self.chapter_selected.emit(-1)
        else:
            self.chapter_selected.emit(self.chapter_list.row(item))
        self.chapter_list.setCurrentItem(item)

    def prev_chapter(self):
        current_row = self.chapter_list.currentRow()
        if current_row > 0:
            self.chapter_list.setCurrentRow(current_row - 1)
            self.chapter_selected.emit(current_row - 1)

    def next_chapter(self):
        current_row = self.chapter_list.currentRow()
        if current_row < self.chapter_list.count() - 1:
            self.chapter_list.setCurrentRow(current_row + 1)
            self.chapter_selected.emit(current_row + 1)
    
    def set_chapter_list(self) -> None:
        chapters = self.chapter_manager.get_chapters()
        if chapters:
            self.chapter_list.clear()
            self.chapter_list.addItems(chapters)


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\gui\dictionary_panel.py
# ========================================

from PyQt5.QtWidgets import (
    QWidget, QLabel, QVBoxLayout, QTextEdit, QLineEdit,
    QPushButton, QScrollArea, QFrame
)
from PyQt5.QtCore import pyqtSlot, Qt
from PyQt5.QtGui import QFont, QTextCharFormat, QTextCursor

class DictionaryPanel(QWidget):
    def __init__(self, dictionary_manager):
        super().__init__()
        self.dictionary_manager = dictionary_manager
        self.setup_ui()

    def setup_ui(self):
        """Set up the dictionary panel UI."""
        layout = QVBoxLayout()

        # Search bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("Search in definitions...")
        self.search_bar.textChanged.connect(self.on_search_text_changed)
        layout.addWidget(self.search_bar)

        # Definition display
        self.definition_display = QTextEdit()
        self.definition_display.setReadOnly(True)
        self.definition_display.setMinimumHeight(200)
        
        # Set up fonts
        default_font = QFont("Open Sans", 10)
        self.definition_display.setFont(default_font)
        
        # Create text formats for different parts
        self.header_format = QTextCharFormat()
        self.header_format.setFontWeight(QFont.Bold)
        self.header_format.setFontPointSize(11)
        
        self.definition_format = QTextCharFormat()
        self.definition_format.setFontPointSize(10)
        
        layout.addWidget(self.definition_display)
        self.setLayout(layout)

    def format_definition(self, dictionary_name: str, definition: str) -> str:
        """Format a definition with proper line breaks and indentation."""
        # Handle special formatting for ThieuChuu and LacViet dictionaries
        if dictionary_name in ['ThieuChuu', 'LacViet']:
            # These dictionaries have structured entries with line breaks and tabs
            # Example: "龢=hòa [huo2]\n\t1. Ðiều hòa, hợp."
            lines = definition.split('\n')
            formatted_lines = []
            for line in lines:
                if line.startswith('\t'):
                    # Indent subpoints with spaces for better readability
                    formatted_lines.append('    ' + line.lstrip('\t'))
                else:
                    formatted_lines.append(line)
            return '\n'.join(formatted_lines)
        else:
            # For other dictionaries, just return the definition as is
            return definition

    @pyqtSlot(str)
    def lookup_word(self, word: str):
        """
        Look up a word and display its definitions.
        
        Args:
            word (str): The word to look up
        """
        self.definition_display.clear()
        cursor = self.definition_display.textCursor()
        
        definitions = self.dictionary_manager.lookup_word(word)
        if definitions:
            # Display definitions in the specified order
            for dict_name in self.dictionary_manager.DICTIONARY_ORDER:
                if dict_name in definitions:
                    # Add dictionary name header
                    cursor.insertText(f"{dict_name}:\n", self.header_format)
                    
                    # Add formatted definition
                    formatted_def = self.format_definition(dict_name, definitions[dict_name])
                    cursor.insertText(f"{formatted_def}\n\n", self.definition_format)
        else:
            cursor.insertText("No definition found.", self.definition_format)

    def on_search_text_changed(self, text: str):
        """
        Handle search text changes.
        
        Args:
            text (str): The search query
        """
        if len(text) < 2:  # Only search if at least 2 characters are entered
            return
            
        self.definition_display.clear()
        cursor = self.definition_display.textCursor()
        
        results = self.dictionary_manager.search_in_definitions(text)
        if results:
            for dict_name in self.dictionary_manager.DICTIONARY_ORDER:
                if dict_name in results:
                    # Add dictionary name header
                    cursor.insertText(f"{dict_name}:\n", self.header_format)
                    
                    # Add each matching entry
                    for word, definition in results[dict_name]:
                        formatted_def = self.format_definition(dict_name, definition)
                        cursor.insertText(f"{word}: {formatted_def}\n", self.definition_format)
                    
                    cursor.insertText("\n")  # Add space between dictionary sections
        else:
            cursor.insertText("No matching definitions found.", self.definition_format)

    def clear_content(self):
        """Clear the panel content."""
        self.search_bar.clear()
        self.definition_display.clear()

    def highlight_search_results(self, text: str):
        """
        Highlight search results in the definition display.
        
        Args:
            text (str): The text to highlight
        """
        if not text:
            return
            
        # Create format for highlighted text
        highlight_format = QTextCharFormat()
        highlight_format.setBackground(Qt.yellow)
        
        # Find and highlight all occurrences
        cursor = self.definition_display.textCursor()
        cursor.movePosition(QTextCursor.Start)
        while cursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor):
            if cursor.selectedText().lower() == text.lower():
                cursor.mergeCharFormat(highlight_format)
            cursor.movePosition(QTextCursor.Right)


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\gui\file_info_panel.py
# ========================================

import os
import chardet
from PyQt5.QtWidgets import (
    QWidget,
    QLabel,
    QVBoxLayout
)

class FileInfoPanel(QWidget):
    def __init__(self, file_handler, translation_manager):
        super().__init__()
        self.file_handler = file_handler
        self.translation_manager = translation_manager
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)
        self.file_name_label = QLabel("File Name: ")
        self.translated_file_name_label = QLabel("Translated File Name: ")
        self.encoding_label = QLabel("Encoding: ")
        self.file_size_label = QLabel("File Size: ")

        layout.addWidget(self.file_name_label)
        layout.addWidget(self.translated_file_name_label)
        layout.addWidget(self.encoding_label)
        layout.addWidget(self.file_size_label)

    def set_file_info(self, file_path):
        file_name = os.path.basename(file_path)
        translated_file_name = self.translation_manager.translate_text(file_name)
        
        try:
            with open(file_path, 'rb') as file:
                raw_data = file.read()
                encoding_result = chardet.detect(raw_data)
                encoding = encoding_result['encoding']
        except Exception as e:
            encoding = "Unknown"

        file_size = os.path.getsize(file_path)
        self.file_name_label.setText(f"File Name: {file_name}")
        self.translated_file_name_label.setText(f"Translated File Name: {translated_file_name}")
        self.encoding_label.setText(f"Encoding: {encoding}")
        self.file_size_label.setText(f"File Size: {file_size} bytes")


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\gui\font_manager.py
# ========================================

import os
from PyQt5.QtGui import QFont, QFontDatabase
from enum import Enum, auto

class FontType(Enum):
    UI = auto()          # For interface elements
    CHINESE = auto()     # For Chinese text
    VIETNAMESE = auto()  # For Vietnamese translations

class FontWeight:
    """Font weight definitions matching common font file naming."""
    THIN = QFont.Thin
    EXTRA_LIGHT = QFont.ExtraLight
    LIGHT = QFont.Light
    REGULAR = QFont.Normal
    MEDIUM = QFont.Medium
    SEMI_BOLD = QFont.DemiBold
    BOLD = QFont.Bold
    EXTRA_BOLD = QFont.ExtraBold
    BLACK = QFont.Black

    @staticmethod
    def from_name(name):
        """Convert weight name to QFont weight value."""
        weights = {
            'thin': QFont.Thin,
            'extralight': QFont.ExtraLight,
            'light': QFont.Light,
            'regular': QFont.Normal,
            'medium': QFont.Medium,
            'semibold': QFont.DemiBold,
            'bold': QFont.Bold,
            'extrabold': QFont.ExtraBold,
            'black': QFont.Black
        }
        return weights.get(name.lower().replace('-', '').replace('_', ''), QFont.Normal)

class FontFamily:
    def __init__(self, name, font_type=FontType.UI):
        self.name = name
        self.font_type = font_type
        self.variable_fonts = {}  # style -> path (e.g., 'regular', 'italic')
        self.static_fonts = {}    # (weight, style) -> path
        self.loaded_ids = set()   # Set of loaded font IDs
        self.loaded = False

    def add_variable_font(self, path, style='regular'):
        """Add a variable font file."""
        self.variable_fonts[style] = path

    def add_static_font(self, path, weight=FontWeight.REGULAR, style='regular'):
        """Add a static font file."""
        self.static_fonts[(weight, style)] = path

    def get_font_path(self, weight=FontWeight.REGULAR, style='regular'):
        """Get the most appropriate font file path for the requested weight and style."""
        # Try variable font first
        if style in self.variable_fonts:
            return self.variable_fonts[style]
        
        # Fall back to static font
        return self.static_fonts.get((weight, style))

class FontManager:
    def __init__(self):
        self.font_families = {}  # name -> FontFamily
        self.current_fonts = {
            FontType.UI: None,
            FontType.CHINESE: None,
            FontType.VIETNAMESE: None
        }

    def scan_font_directory(self, directory, font_type=None):
        """Scan a directory for fonts and add them to the manager."""
        if not os.path.exists(directory):
            return False

        for item in os.listdir(directory):
            item_path = os.path.join(directory, item)
            if os.path.isdir(item_path):
                self._scan_font_family(item_path, item, font_type)

        return True

    def _scan_font_family(self, directory, family_name, font_type=None):
        """Scan a font family directory and add its fonts."""
        family = FontFamily(family_name, font_type)

        # Check for variable fonts in main directory
        for file in os.listdir(directory):
            if 'variable' in file.lower() and file.endswith(('.ttf', '.otf')):
                style = 'italic' if 'italic' in file.lower() else 'regular'
                family.add_variable_font(os.path.join(directory, file), style)

        # Check for static fonts
        static_dir = os.path.join(directory, 'static')
        if os.path.exists(static_dir):
            for file in os.listdir(static_dir):
                if file.endswith(('.ttf', '.otf')):
                    path = os.path.join(static_dir, file)
                    style = 'italic' if 'italic' in file.lower() else 'regular'
                    weight = self._detect_weight_from_filename(file)
                    family.add_static_font(path, weight, style)

        self.font_families[family_name] = family

    def _detect_weight_from_filename(self, filename):
        """Detect font weight from filename."""
        filename = filename.lower()
        if 'thin' in filename: return FontWeight.THIN
        if 'extralight' in filename: return FontWeight.EXTRA_LIGHT
        if 'light' in filename: return FontWeight.LIGHT
        if 'medium' in filename: return FontWeight.MEDIUM
        if 'semibold' in filename: return FontWeight.SEMI_BOLD
        if 'bold' in filename:
            if 'extra' in filename or 'ultra' in filename:
                return FontWeight.EXTRA_BOLD
            return FontWeight.BOLD
        if 'black' in filename: return FontWeight.BLACK
        return FontWeight.REGULAR

    def add_font_file(self, path, family_name=None, weight=None, style='regular', font_type=None):
        """Add a single font file to the manager."""
        if not os.path.exists(path):
            return False

        # Use filename as family name if not provided
        if not family_name:
            family_name = os.path.splitext(os.path.basename(path))[0]
            family_name = family_name.split('-')[0]  # Remove weight/style suffixes

        # Create family if it doesn't exist
        if family_name not in self.font_families:
            self.font_families[family_name] = FontFamily(family_name, font_type)

        family = self.font_families[family_name]
        
        # Detect if it's a variable font
        if 'variable' in path.lower():
            family.add_variable_font(path, style)
        else:
            if weight is None:
                weight = self._detect_weight_from_filename(os.path.basename(path))
            family.add_static_font(path, weight, style)

        return True

    def load_font_family(self, family_name):
        """Load a font family into the system."""
        if family_name not in self.font_families:
            return False

        family = self.font_families[family_name]
        if family.loaded:
            return True

        try:
            # Load variable fonts
            for path in family.variable_fonts.values():
                font_id = QFontDatabase.addApplicationFont(path)
                if font_id != -1:
                    family.loaded_ids.add(font_id)
                    family.loaded = True

            # Load static fonts if no variable fonts were loaded
            if not family.loaded:
                for path in family.static_fonts.values():
                    font_id = QFontDatabase.addApplicationFont(path)
                    if font_id != -1:
                        family.loaded_ids.add(font_id)
                        family.loaded = True

            return family.loaded

        except Exception as e:
            print(f"Error loading font family {family_name}: {e}")
            return False

    def create_font(self, family_name, size=10, weight=FontWeight.REGULAR):
        """Create a QFont object for the specified family."""
        if family_name not in self.font_families:
            return QFont()

        # Load font if not already loaded
        if not self.font_families[family_name].loaded:
            if not self.load_font_family(family_name):
                return QFont()

        font = QFont(family_name)
        font.setPointSize(size)
        font.setWeight(weight)
        return font

    def set_font(self, font_type, family_name, size=10, weight=FontWeight.REGULAR):
        """Set the current font for a specific type."""
        if family_name not in self.font_families:
            return False

        font = self.create_font(family_name, size, weight)
        if font:
            self.current_fonts[font_type] = font
            return True
        return False

    def get_current_font(self, font_type):
        """Get the current font for a specific type."""
        return self.current_fonts.get(font_type)

    def apply_font_to_widget(self, widget, font_type):
        """Apply the current font of a specific type to a widget."""
        font = self.current_fonts.get(font_type)
        if font:
            widget.setFont(font)
            return True
        return False

    def get_font_families(self, font_type=None):
        """Get list of available font families, optionally filtered by type."""
        if font_type is None:
            return list(self.font_families.keys())
        return [name for name, family in self.font_families.items() 
                if family.font_type == font_type]

# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\gui\main_translation_panel.py
# ========================================

from PyQt5.QtWidgets import QTextEdit, QWidget, QVBoxLayout, QPushButton, QHBoxLayout, QPlainTextEdit
from PyQt5.QtCore import Qt, pyqtSignal, QPoint
from PyQt5.QtGui import (
    QTextCursor, QTextCharFormat, QColor, QTextBlockFormat, 
    QTextDocument, QTextBlockUserData, QTextBlock
)
from typing import Optional, Dict, Tuple, List
from src.core.chapter_manager import ChapterManager
from src.core.translation_manager import TranslationManager
from src.QTEngine.src.text_processing import TranslationMapping, Block

class TextSegment:
    """Represents a segment of text with its mapping."""
    def __init__(self, text: str, start_pos: int, is_original: bool, mapping_block: Optional[Block] = None):
        self.text = text
        self.start_pos = start_pos
        self.end_pos = start_pos + len(text)
        self.is_original = is_original
        self.mapping_block = mapping_block

class TranslationTextEdit(QPlainTextEdit):
    """Custom QPlainTextEdit that handles mouse events for dictionary lookup."""
    segment_clicked = pyqtSignal(TextSegment)  # Emits the clicked segment

    def __init__(self):
        super().__init__()
        self.setReadOnly(True)
        self.segments: List[TextSegment] = []
        
        # Set up text formats
        self.highlight_format = QTextCharFormat()
        self.highlight_format.setBackground(QColor(255, 255, 0, 100))  # Light yellow
        self.original_format = QTextCharFormat()
        self.original_format.setBackground(QColor(240, 240, 255))  # Light blue
        self.translated_format = QTextCharFormat()
        self.translated_format.setBackground(QColor(240, 255, 240))  # Light green

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            # Get cursor position at click
            cursor = self.cursorForPosition(event.pos())
            pos = cursor.position()
            
            # Find which segment was clicked
            clicked_segment = self.find_segment_at_position(pos)
            if clicked_segment:
                self.segment_clicked.emit(clicked_segment)
        
        super().mousePressEvent(event)

    def find_segment_at_position(self, pos: int) -> Optional[TextSegment]:
        """Find the text segment at the given position."""
        for segment in self.segments:
            if segment.start_pos <= pos < segment.end_pos:
                return segment
        return None

    def clear_segments(self):
        """Clear all segments."""
        self.segments.clear()
        self.clear()

    def add_segment(self, segment: TextSegment):
        """Add a new text segment."""
        self.segments.append(segment)
        
        # Create cursor at segment position
        cursor = QTextCursor(self.document())
        cursor.setPosition(segment.start_pos)
        
        # Set format based on whether it's original or translated
        format = self.original_format if segment.is_original else self.translated_format
        cursor.setCharFormat(format)
        
        # Insert the text
        cursor.insertText(segment.text)

class MainTranslationPanel(QWidget):
    def __init__(self, parent: Optional[QWidget], chapter_manager: ChapterManager,
                 translation_manager: TranslationManager, dictionary_panel):
        super().__init__(parent)
        self.chapter_manager = chapter_manager
        self.translation_manager = translation_manager
        self.dictionary_panel = dictionary_panel
        
        # Create text edit
        self.text_edit = TranslationTextEdit()
        self.text_edit.segment_clicked.connect(self.handle_segment_click)
        
        # Create toggle button
        self.show_original = False
        self.toggle_button = QPushButton("Show Original Text")
        self.toggle_button.clicked.connect(self.toggle_text_display)
        
        # Layout
        layout = QVBoxLayout()
        button_layout = QHBoxLayout()
        button_layout.addWidget(self.toggle_button)
        layout.addLayout(button_layout)
        layout.addWidget(self.text_edit)
        self.setLayout(layout)

    def set_chapter_text(self, chapter_index: int):
        """Set the text for a chapter."""
        self.text_edit.clear_segments()
        
        # Get original text and translate
        original_text = self.chapter_manager.get_chapter_text(chapter_index)
        if not original_text:
            return
            
        # Process each paragraph
        current_pos = 0
        paragraphs = original_text.splitlines(keepends=True)
        for paragraph in paragraphs:
            if not paragraph.strip():
                current_pos += len(paragraph)
                continue
                
            # Get translation and mapping
            translated_text = self.translation_manager.translate_text(paragraph.strip())
            mapping = self.translation_manager.current_mapping
            
            if self.show_original:
                # Add original text segments
                for block in mapping.blocks:
                    segment = TextSegment(
                        block.original,
                        current_pos,
                        True,
                        block
                    )
                    self.text_edit.add_segment(segment)
                    current_pos += len(block.original)
                
                # Add newline between original and translation
                self.text_edit.add_segment(TextSegment("\n", current_pos, True))
                current_pos += 1
                
                # Add translated text segments
                for block in mapping.blocks:
                    segment = TextSegment(
                        block.translated,
                        current_pos,
                        False,
                        block
                    )
                    self.text_edit.add_segment(segment)
                    current_pos += len(block.translated)
            else:
                # Add only translated text segments
                for block in mapping.blocks:
                    segment = TextSegment(
                        block.translated,
                        current_pos,
                        False,
                        block
                    )
                    self.text_edit.add_segment(segment)
                    current_pos += len(block.translated)
            
            # Add paragraph break
            self.text_edit.add_segment(TextSegment(paragraph[len(paragraph.strip()):], current_pos, False))
            current_pos += len(paragraph[len(paragraph.strip()):])

    def handle_segment_click(self, segment: TextSegment):
        """Handle when a text segment is clicked."""
        if not segment.mapping_block:
            return
            
        # Clear any existing highlights
        cursor = self.text_edit.textCursor()
        cursor.select(QTextCursor.Document)
        cursor.setCharFormat(QTextCharFormat())
        
        # Highlight the clicked segment and its corresponding translation/original
        for other_segment in self.text_edit.segments:
            if other_segment.mapping_block == segment.mapping_block:
                cursor = self.text_edit.textCursor()
                cursor.setPosition(other_segment.start_pos)
                cursor.setPosition(other_segment.end_pos, QTextCursor.KeepAnchor)
                cursor.setCharFormat(self.text_edit.highlight_format)
        
        # Look up the word
        if segment.is_original:
            self.dictionary_panel.lookup_word(segment.text)
        else:
            original_segment = next(
                (s for s in self.text_edit.segments 
                 if s.mapping_block == segment.mapping_block and s.is_original),
                None
            )
            if original_segment:
                self.dictionary_panel.lookup_word(original_segment.text)

    def toggle_text_display(self):
        """Toggle between showing original and translated text."""
        self.show_original = not self.show_original
        self.toggle_button.setText("Hide Original Text" if self.show_original else "Show Original Text")
        
        if self.chapter_manager.chapters:
            self.set_chapter_text(0)

    def set_text(self, text: str):
        """Set the entire text content."""
        self.chapter_manager.set_text(text)
        if self.chapter_manager.chapters:
            self.set_chapter_text(0)


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\gui\main_window.py
# ========================================

from PyQt5.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QScrollArea, QFileDialog
from PyQt5.QtCore import Qt, pyqtSignal
from src.gui.file_info_panel import FileInfoPanel
from src.gui.chapter_panel import ChapterPanel
from src.gui.dictionary_panel import DictionaryPanel
from src.gui.main_translation_panel import MainTranslationPanel
from src.gui.menu_bar import MenuBar
#from src.utils.qt_utils import create_font
class MainWindow(QMainWindow):
    def __init__(self, translation_manager, dictionary_manager, chapter_manager):
        super().__init__()
        self.translation_manager = translation_manager
        self.dictionary_manager = dictionary_manager
        self.chapter_manager = chapter_manager
        self.setWindowTitle("ZXReader")
        self.setGeometry(100, 100, 1200, 800)
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QVBoxLayout(self.central_widget)
        self.menu_bar = MenuBar(self)
        self.setMenuBar(self.menu_bar)
        self.main_content_layout = QHBoxLayout()
        self.main_layout.addLayout(self.main_content_layout)
        self.left_panel_layout = QVBoxLayout()
        self.main_content_layout.addLayout(self.left_panel_layout)
        self.right_panel_layout = QVBoxLayout()
        self.main_content_layout.addLayout(self.right_panel_layout)

        # Initialize panels with proper parent and managers
        self.file_info_panel = FileInfoPanel(self, self.translation_manager)
        self.left_panel_layout.addWidget(self.file_info_panel)
        
        self.chapter_panel = ChapterPanel(self, self.chapter_manager, self.translation_manager)
        self.left_panel_layout.addWidget(self.chapter_panel)
        
        self.dictionary_panel = DictionaryPanel(self.dictionary_manager)
        self.left_panel_layout.addWidget(self.dictionary_panel)
        
        self.main_translation_panel = MainTranslationPanel(self, self.chapter_manager, self.translation_manager, self.dictionary_panel)
        self.right_panel_layout.addWidget(self.main_translation_panel)

        # Connect signals with correct signal names
        self.menu_bar.file_opened.connect(self.set_file_info)
        self.chapter_panel.chapter_selected.connect(self.set_chapter_text)
        self.chapter_panel.chapter_changed.connect(self.set_chapter_list)
    
    def open_file_dialog(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "Open File", "", "Text Files (*.txt)")
        if file_path:
            self.set_file_info(file_path)
            with open(file_path, 'r', encoding='utf-8') as f:
                text = f.read()
                self.main_translation_panel.set_text(text)
    
    def set_file_info(self, file_path):
        self.file_info_panel.set_file_info(file_path)
    def set_chapter_text(self, chapter_text):
         self.main_translation_panel.set_chapter_text(chapter_text)
    def set_chapter_list(self, chapter_list):
        self.main_translation_panel.set_chapter_list(chapter_list)
if __name__ == '__main__':
    from PyQt5.QtWidgets import QApplication
    from src.core.translation_manager import TranslationManager
    from src.core.dictionary_manager import DictionaryManager
    from src.core.chapter_manager import ChapterManager
    from src.QTEngine.QTEngine import QTEngine
    import sys
    app = QApplication(sys.argv)
    qt_engine = QTEngine()
    translation_manager = TranslationManager(qt_engine)
    dictionary_manager = DictionaryManager(qt_engine)
    chapter_manager = ChapterManager(qt_engine)
    main_window = MainWindow(translation_manager, dictionary_manager, chapter_manager)
    main_window.show()
    sys.exit(app.exec_())


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\gui\menu_bar.py
# ========================================

from PyQt5.QtWidgets import QMenuBar, QMenu, QAction
from PyQt5.QtCore import pyqtSignal

class MenuBar(QMenuBar):
    file_opened = pyqtSignal(str)
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.init_menus()

    def init_menus(self):
        file_menu = QMenu("File", self)
        self.addMenu(file_menu)

        open_file_action = QAction("Open", self)
        open_file_action.triggered.connect(self.open_file)
        file_menu.addAction(open_file_action)
        
        save_file_action = QAction("Save", self)
        file_menu.addAction(save_file_action)
        
        save_as_file_action = QAction("Save As", self)
        file_menu.addAction(save_as_file_action)
        
        exit_action = QAction("Exit", self)
        file_menu.addAction(exit_action)
        
        edit_menu = QMenu("Edit", self)
        self.addMenu(edit_menu)
        
        copy_action = QAction("Copy", self)
        edit_menu.addAction(copy_action)
        
        paste_action = QAction("Paste", self)
        edit_menu.addAction(paste_action)
        
        cut_action = QAction("Cut", self)
        edit_menu.addAction(cut_action)
        
        select_all_action = QAction("Select All", self)
        edit_menu.addAction(select_all_action)
        
        view_menu = QMenu("View", self)
        self.addMenu(view_menu)
        
        zoom_in_action = QAction("Zoom In", self)
        view_menu.addAction(zoom_in_action)
        
        zoom_out_action = QAction("Zoom Out", self)
        view_menu.addAction(zoom_out_action)
        
        reset_zoom_action = QAction("Reset Zoom", self)
        view_menu.addAction(reset_zoom_action)
        
        help_menu = QMenu("Help", self)
        self.addMenu(help_menu)
        
        about_action = QAction("About", self)
        help_menu.addAction(about_action)
    
    def open_file(self):
        self.main_window.open_file_dialog()


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\gui\style_manager.py
# ========================================

from PyQt5.QtWidgets import QWidget
from typing import Optional
from PyQt5.QtGui import QFont

class StyleManager:
    def __init__(self) -> None:
        self.current_theme = "light"

    def get_style(self) -> str:
        if self.current_theme == "light":
            return """
                QMainWindow {
                    background-color: #f0f0f0;
                }
                QWidget {
                    background-color: #f0f0f0;
                    color: #333;
                }
                QMenuBar {
                    background-color: #e0e0e0;
                    color: #333;
                }
                QMenuBar::item {
                    background-color: #e0e0e0;
                    color: #333;
                }
                QMenuBar::item::selected {
                    background-color: #d0d0d0;
                }
                QMenu {
                    background-color: #e0e0e0;
                    color: #333;
                }
                QMenu::item::selected {
                    background-color: #d0d0d0;
                }
                QLabel {
                    color: #333;
                }
                QTextEdit {
                    background-color: #fff;
                    color: #333;
                }
                QComboBox {
                    background-color: #fff;
                    color: #333;
                }
                QPushButton {
                    background-color: #e0e0e0;
                    color: #333;
                }
                QPushButton::hover {
                    background-color: #d0d0d0;
                }
            """
        elif self.current_theme == "dark":
            return """
                QMainWindow {
                    background-color: #333;
                }
                QWidget {
                    background-color: #333;
                    color: #f0f0f0;
                }
                 QMenuBar {
                    background-color: #444;
                    color: #f0f0f0;
                }
                QMenuBar::item {
                    background-color: #444;
                    color: #f0f0f0;
                }
                QMenuBar::item::selected {
                    background-color: #555;
                }
                QMenu {
                    background-color: #444;
                    color: #f0f0f0;
                }
                QMenu::item::selected {
                    background-color: #555;
                }
                QLabel {
                    color: #f0f0f0;
                }
                QTextEdit {
                    background-color: #555;
                    color: #f0f0f0;
                }
                QComboBox {
                    background-color: #555;
                    color: #f0f0f0;
                }
                QPushButton {
                    background-color: #444;
                    color: #f0f0f0;
                }
                QPushButton::hover {
                    background-color: #555;
                }
            """
        elif self.current_theme == "book":
            return """
                QMainWindow {
                    background-color: #f5f0e1;
                }
                QWidget {
                    background-color: #f5f0e1;
                    color: #333;
                }
                QMenuBar {
                    background-color: #e8e0d1;
                    color: #333;
                }
                QMenuBar::item {
                    background-color: #e8e0d1;
                    color: #333;
                }
                QMenuBar::item::selected {
                    background-color: #d0c8b8;
                }
                QMenu {
                    background-color: #e8e0d1;
                    color: #333;
                }
                QMenu::item::selected {
                    background-color: #d0c8b8;
                }
                QLabel {
                    color: #333;
                }
                QTextEdit {
                    background-color: #fff;
                    color: #333;
                }
                QComboBox {
                    background-color: #fff;
                    color: #333;
                }
                QPushButton {
                    background-color: #e8e0d1;
                    color: #333;
                }
                QPushButton::hover {
                    background-color: #d0c8b8;
                }
            """
        elif self.current_theme == "wood":
            return """
                QMainWindow {
                    background-color: #a38b6a;
                }
                QWidget {
                    background-color: #a38b6a;
                    color: #f0f0f0;
                }
                QMenuBar {
                    background-color: #8a7357;
                    color: #f0f0f0;
                }
                QMenuBar::item {
                    background-color: #8a7357;
                    color: #f0f0f0;
                }
                QMenuBar::item::selected {
                    background-color: #715e46;
                }
                QMenu {
                    background-color: #8a7357;
                    color: #f0f0f0;
                }
                QMenu::item::selected {
                    background-color: #715e46;
                }
                QLabel {
                    color: #f0f0f0;
                }
                QTextEdit {
                    background-color: #b9a58a;
                    color: #f0f0f0;
                }
                QComboBox {
                    background-color: #b9a58a;
                    color: #f0f0f0;
                }
                QPushButton {
                    background-color: #8a7357;
                    color: #f0f0f0;
                }
                QPushButton::hover {
                    background-color: #715e46;
                }
            """
        return ""

    def apply_style(self, widget: QWidget) -> None:
        style = self.get_style()
        widget.setStyleSheet(style)

    def load_fonts(self) -> None:
        # Load custom fonts if needed
        pass

    def set_font(self, widget: QWidget, font_name: str = "Arial", size: int = 10) -> None:
        font = QFont(font_name, size)
        widget.setFont(font)

    def set_theme(self, theme: str) -> None:
        self.current_theme = theme


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\config.py
# ========================================

"""
Configuration constants for QTEngine.

This module centralizes configuration parameters to make them easily 
modifiable without changing core implementation code.
"""

import os
from typing import Dict, Any

# Project Paths
PROJECT_PATHS = {
    'root': os.path.dirname(os.path.abspath(__file__)),
    'src': os.path.join(os.path.dirname(os.path.abspath(__file__)), 'src'),
    'data': os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data'),
    'models': os.path.join(os.path.dirname(os.path.abspath(__file__)), 'models')
}

# Data Loader Configuration
DATA_LOADER_CONFIG = {
    'data_directory': PROJECT_PATHS['data'],
    'required_files': [
        'Names2.txt', 
        'Names.txt', 
        'VietPhrase.txt'
    ],
    'encoding': 'utf-8',
    'min_entries': 10,  # Minimum entries required for a valid translation file
    'cache_enabled': True,
    'cache_duration_minutes': 60
}

# Translation Configuration
TRANSLATION_CONFIG = {
    'default_strategy': 'trie_based',
    'fallback_strategy': 'character_conversion',
    'performance_logging': True,
    'quality_threshold': 0.7,
    'parallel_processing': True,
    'use_rust_trie': True  # New configuration for Rust Trie
}

# Logging Configuration
LOGGING_CONFIG = {
    'level': 'INFO',
    'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    'file': os.path.join(PROJECT_PATHS['root'], 'qtengine.log')
}

def get_config(config_type: str = 'default') -> Dict[str, Any]:
    """
    Retrieve configuration dictionary based on type.
    
    :param config_type: Type of configuration to retrieve
    :return: Configuration dictionary
    """
    config_map = {
        'data_loader': DATA_LOADER_CONFIG,
        'translation': TRANSLATION_CONFIG,
        'logging': LOGGING_CONFIG,
        'default': {**DATA_LOADER_CONFIG, **TRANSLATION_CONFIG, **LOGGING_CONFIG}
    }
    
    return config_map.get(config_type, config_map['default'])

# Optional: Validate configuration on import
def validate_config():
    """
    Validate configuration settings.
    """
    assert os.path.exists(PROJECT_PATHS['data']), f"Data directory not found: {PROJECT_PATHS['data']}"
    assert len(DATA_LOADER_CONFIG['required_files']) > 0, "No required files specified"
    assert DATA_LOADER_CONFIG['min_entries'] >= 0, "Minimum entries must be non-negative"

validate_config()


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\QTEngine.py
# ========================================

import re
import logging
from typing import Dict, List, Tuple, Optional, Any, Callable

from src.QTEngine.models.trie import Trie
from src.QTEngine.models.chinese_converter import ChineseConverter

# Import the new modularized functions
from src.QTEngine.src.character_utils import LATIN_CHARS, replace_special_chars
from src.QTEngine.src.text_processing import (
    convert_to_sino_vietnamese, 
    rephrase, 
    process_paragraph,
    TranslationMapping
)
from src.QTEngine.src.performance import profile_function
from src.QTEngine.src.data_loader import load_data, DataLoader
from src.QTEngine.src.translation_engine import TranslationEngine

class QTEngine(TranslationEngine):
    """
    A translation engine for converting Chinese text to Sino-Vietnamese.
    
    Attributes:
        names2 (Trie): Trie for Names2 data
        names (Trie): Trie for Names data
        viet_phrase (Trie): Trie for VietPhrase data
        chinese_phien_am (Dict[str, str]): Dictionary of Chinese Phien Am words
        loading_info (Dict[str, Any]): Information about data loading
        chinese_converter (ChineseConverter): Converter for Traditional to Simplified Chinese
    """
    
    def __init__(self, 
                 data_loader: Optional[DataLoader] = None, 
                 config: Optional[Dict[str, Any]] = None):
        """
        Initialize the QTEngine with optional data loader and configuration.
        
        Args:
            data_loader (Optional[DataLoader]): Custom data loader
            config (Optional[Dict[str, Any]]): Configuration dictionary
        """
        super().__init__(data_loader, config)
        
        # Use provided data loader or create a default one
        self.data_loader = data_loader or DataLoader()
        
        # Load translation data
        self.names2, self.names, self.viet_phrase, self.chinese_phien_am, self.loading_info = self.data_loader.load_data()
        
        # Store configuration
        self.config = config or {}
        
        # Initialize Chinese converter
        self.chinese_converter = ChineseConverter()
        
        # Configure logging
        self.logger = logging.getLogger(__name__)
    
    def translate(self, text: str) -> str:
        """
        Translate Chinese text to Sino-Vietnamese.
        
        Args:
            text (str): Input Chinese text
        
        Returns:
            str: Translated Sino-Vietnamese text
        """
        try:
            translated_text, _ = process_paragraph(
                text, 
                self.names2, 
                self.names, 
                self.viet_phrase, 
                self.chinese_phien_am
            )
            return translated_text
        except Exception as e:
            self.logger.error(f"Translation failed: {e}")
            raise

    def translate_with_mapping(self, text: str) -> Tuple[str, TranslationMapping]:
        """
        Translate Chinese text to Sino-Vietnamese and return mapping information.
        
        Args:
            text (str): Input Chinese text
        
        Returns:
            Tuple[str, TranslationMapping]: Translated text and mapping information
        """
        try:
            # First convert Traditional to Simplified if necessary
            simplified_text = self.chinese_converter.auto_convert_to_simplified(text)
            if simplified_text is None:
                simplified_text = text

            return process_paragraph(
                simplified_text,
                self.names2,
                self.names,
                self.viet_phrase,
                self.chinese_phien_am
            )
        except Exception as e:
            self.logger.error(f"Translation with mapping failed: {e}")
            raise
    
    def validate_translation(self, original: str, translated: str) -> bool:
        """
        Validate the quality of translation.
        
        Args:
            original (str): Original Chinese text
            translated (str): Translated Sino-Vietnamese text
        
        Returns:
            bool: Whether the translation meets quality standards
        """
        # Basic validation checks
        if not original or not translated:
            return False
        
        # Check if translation length is reasonable
        length_ratio = len(translated) / len(original)
        if length_ratio < 0.5 or length_ratio > 2.0:
            self.logger.warning("Translation length is significantly different from original")
            return False
        
        return True
    
    def refresh_data(self):
        """
        Refresh translation data using the data loader.
        """
        try:
            (
                self.names2, 
                self.names, 
                self.viet_phrase, 
                self.chinese_phien_am, 
                self.loading_info
            ) = self.data_loader.load_data()
            self.logger.info("Translation data refreshed successfully")
        except Exception as e:
            self.logger.error(f"Data refresh failed: {e}")
            raise
    
    def get_translation_metadata(self) -> Dict[str, Any]:
        """
        Retrieve metadata about the translation process.
        
        Returns:
            Dict[str, Any]: Translation metadata
        """
        return {
            'loading_info': self.loading_info,
            'data_sources': {
                'names2_size': len(self.names2.get_all_words()),
                'names_size': len(self.names.get_all_words()),
                'viet_phrase_size': len(self.viet_phrase.get_all_words()),
                'chinese_phien_am_size': len(self.chinese_phien_am)
            }
        }
    
    def rephrase_tokens(self, tokens: List[str]) -> str:
        """
        Rephrase tokens to form a properly formatted sentence.
        
        Args:
            tokens (List[str]): List of tokens to rephrase
        
        Returns:
            str: Rephrased sentence
        """
        return rephrase(tokens)
    
    def process_text(self, text: str, additional_processing: Optional[Callable[[str], str]] = None) -> str:
        """
        Process text with optional additional processing.
        
        Args:
            text (str): Input text
            additional_processing (Optional[Callable]): Optional additional processing function
        
        Returns:
            str: Processed text
        """
        # Translate the text
        translated = self.translate(text)
        
        # Apply additional processing if provided
        if additional_processing:
            translated = additional_processing(translated)
        
        return translated
    
    def translate_paragraph(self, paragraph: str) -> str:
        """
        Backward-compatible method for translating a single paragraph.
        
        Args:
            paragraph (str): The input paragraph in Chinese.
        
        Returns:
            str: The translated paragraph in Sino-Vietnamese.
        """
        # First convert Traditional to Simplified if necessary
        simplified_text = self.chinese_converter.auto_convert_to_simplified(paragraph)
        if simplified_text is None:
            simplified_text = paragraph
            
        translated_text, _ = process_paragraph(
            simplified_text, 
            self.names2, 
            self.names, 
            self.viet_phrase, 
            self.chinese_phien_am
        )
        return translated_text
    
    def get_loading_info(self) -> Dict[str, Any]:
        """
        Backward-compatible method to get loading information.
        
        Returns:
            Dict[str, Any]: Dictionary containing loading information.
        """
        return self.loading_info

# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\__init__.py
# ========================================

from .QTEngine import QTEngine
from .src.translation_engine import TranslationEngine
from .src.data_loader import DataLoader

__all__ = ['QTEngine', 'TranslationEngine', 'DataLoader']


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\models\chinese_converter.py
# ========================================

from typing import Optional
import opencc
import re

class ChineseConverter:
    def __init__(self):
        # Initialize converters
        self.t2s = opencc.OpenCC('t2s')  # Traditional to Simplified
        self.s2t = opencc.OpenCC('s2t')  # Simplified to Traditional
        
        # Common Traditional-only characters
        self.traditional_chars = set('繁體國說壽麗華實現觀點愛爾蘭寫藝術')
    
    def has_chinese(self, text: str) -> bool:
        """Check if the text contains Chinese characters."""
        chinese_pattern = re.compile(r'[\u4e00-\u9fff]')
        return bool(chinese_pattern.search(text))
    
    def is_traditional(self, text: str) -> bool:
        """
        Detect if the Chinese text is Traditional Chinese by checking for
        the presence of Traditional-specific characters.
        """
        if not self.has_chinese(text):
            return False
            
        # Convert text to simplified
        simplified = self.t2s.convert(text)
        
        # If the conversion changes the text, it's likely Traditional
        if simplified != text:
            # Double check by looking for Traditional-specific characters
            for char in text:
                if char in self.traditional_chars:
                    return True
            
            # If no specific Traditional chars found but text changed, still likely Traditional
            return True
            
        return False
    
    def convert_to_simplified(self, text: str) -> str:
        """Convert Chinese text to Simplified Chinese."""
        if not self.has_chinese(text):
            return text
        return self.t2s.convert(text)
    
    def convert_to_traditional(self, text: str) -> str:
        """Convert Chinese text to Traditional Chinese."""
        if not self.has_chinese(text):
            return text
        return self.s2t.convert(text)
    
    def auto_convert_to_simplified(self, text: str) -> Optional[str]:
        """
        Automatically detect if the text is Traditional Chinese and convert to Simplified if it is.
        Returns None if no Chinese characters are found.
        """
        if not self.has_chinese(text):
            return None
            
        # Always convert to simplified to ensure consistency
        simplified = self.convert_to_simplified(text)
        return simplified if simplified != text else text


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\models\trie.py
# ========================================

from typing import Dict, List, Tuple, Optional, Union
import sys

class TrieNode:
    __slots__ = ['children', 'is_end_of_word', 'value']
    def __init__(self):
        self.children: Dict[str, 'TrieNode'] = {}
        self.is_end_of_word: bool = False
        self.value: Optional[str] = None

class Trie:
    def __init__(self, memory_optimize: bool = False):
        """
        Initialize a Trie data structure.
        
        Args:
            memory_optimize (bool): If True, uses more memory-efficient strategies.
        """
        self.root: TrieNode = TrieNode()
        self.word_count: int = 0
        self._memory_optimize = memory_optimize

    def insert(self, word: str, value: str) -> None:
        """
        Insert a word and its associated value into the Trie.
        
        Args:
            word (str): The key to insert
            value (str): The value associated with the key
        """
        current = self.root
        for char in word:
            if char not in current.children:
                current.children[char] = TrieNode()
            current = current.children[char]
        current.is_end_of_word = True
        current.value = value
        self.word_count += 1

        # Optional memory optimization
        if self._memory_optimize and sys.getsizeof(current.children) > 1024:
            current.children = dict(list(current.children.items())[:10])  # Keep only 10 most recent

    def batch_insert(self, words: List[Tuple[str, str]]) -> None:
        """
        Insert multiple words at once.
        
        Args:
            words (List[Tuple[str, str]]): List of (word, value) tuples
        """
        for word, value in words:
            self.insert(word, value)

    def contains(self, word: str) -> bool:
        """
        Check if a word exists in the Trie.
        
        Args:
            word (str): Word to check
        
        Returns:
            bool: True if word exists, False otherwise
        """
        current = self.root
        for char in word:
            if char not in current.children:
                return False
            current = current.children[char]
        return current.is_end_of_word

    def count(self) -> int:
        """
        Get the total number of words in the Trie.
        
        Returns:
            int: Number of words
        """
        return self.word_count

    def find_longest_prefix(self, text: str) -> Tuple[str, Optional[str]]:
        """
        Find the longest prefix match in the Trie.
        
        Args:
            text (str): Text to find prefix in
        
        Returns:
            Tuple[str, Optional[str]]: Longest prefix and its associated value
        """
        current = self.root
        longest_prefix = ""
        longest_value = None
        prefix = []
        for char in text:
            if char not in current.children:
                break
            current = current.children[char]
            prefix.append(char)
            if current.is_end_of_word:
                longest_prefix = ''.join(prefix)
                longest_value = current.value
        return longest_prefix, longest_value

    def get_all_words(self) -> List[Tuple[str, str]]:
        """
        Retrieve all words and their values from the Trie.
        
        Returns:
            List[Tuple[str, str]]: List of (word, value) tuples
        """
        words = []
        def dfs(node: TrieNode, current_word: str):
            if node.is_end_of_word:
                words.append((current_word, node.value))
            for char, child_node in node.children.items():
                dfs(child_node, current_word + char)
        
        dfs(self.root, "")
        return words

# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\src\character_utils.py
# ========================================

from typing import Set, Dict
from src.QTEngine.src.ReplaceChar import SPECIAL_CHARS

# Comprehensive set of Latin characters including various language variants
LATIN_CHARS: Set[str] = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                  'àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđ'  # Vietnamese
                  'ÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸĐ'
                  'áéíóúýàèìòùâêîôûãõñäëïöüÿçß'  # French, German, Spanish, Portuguese
                  'ÁÉÍÓÚÝÀÈÌÒÙÂÊÎÔÛÃÕÑÄËÏÖÜŸÇSS')  # Uppercase variants

def replace_special_chars(text: str) -> str:
    """
    Replace special characters in the text with their Vietnamese equivalents.

    Args:
        text (str): The input text containing special characters.

    Returns:
        str: The text with special characters replaced.
    """
    for han, viet in SPECIAL_CHARS.items():
        text = text.replace(han, viet)
    return text


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\src\data_loader.py
# ========================================

import os
import time
import logging
import hashlib
from typing import Tuple, Dict, Any, Optional, List, Union
from functools import lru_cache, wraps
from datetime import datetime, timedelta

from src.QTEngine.models.trie import Trie
import src.QTEngine.config as config

# Configure logging based on config
logging.basicConfig(
    level=getattr(logging, config.LOGGING_CONFIG['level']),
    format=config.LOGGING_CONFIG['format']
)
logger = logging.getLogger(__name__)

class DataLoadError(Exception):
    """Custom exception for data loading errors."""
    pass

class DataValidator:
    """Utility class for validating loaded data."""
    
    @staticmethod
    def validate_trie(trie: Trie, min_entries: int = 10) -> bool:
        """
        Validate a Trie data structure.
        
        Args:
            trie (Trie): Trie to validate
            min_entries (int): Minimum number of expected entries
        
        Returns:
            bool: Whether the Trie is valid
        """
        if not isinstance(trie, Trie):
            logger.error("Invalid Trie type")
            return False
        
        trie_size = trie.count()
        if trie_size < min_entries:
            logger.warning(f"Trie has fewer entries than expected: {trie_size}")
            return False
        
        return True
    
    @staticmethod
    def validate_dictionary(data: Dict[str, str], min_entries: int = 10) -> bool:
        """
        Validate a dictionary data structure.
        
        Args:
            data (Dict[str, str]): Dictionary to validate
            min_entries (int): Minimum number of expected entries
        
        Returns:
            bool: Whether the dictionary is valid
        """
        if not isinstance(data, dict):
            logger.error("Invalid dictionary type")
            return False
        
        if len(data) < min_entries:
            logger.warning(f"Dictionary has fewer entries than expected: {len(data)}")
            return False
        
        return all(isinstance(k, str) and isinstance(v, str) for k, v in data.items())

def retry_on_failure(max_retries: int = 3, delay: int = 1):
    """
    Decorator to retry a function on failure.
    
    Args:
        max_retries (int): Maximum number of retries
        delay (int): Delay between retries in seconds
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    logger.warning(f"Attempt {attempt + 1} failed: {e}")
                    if attempt == max_retries - 1:
                        raise
                    time.sleep(delay * (attempt + 1))
        return wrapper
    return decorator

@lru_cache(maxsize=config.DATA_LOADER_CONFIG['cache_enabled'] and 32 or 0)
def load_file_cached(file_path: str) -> Dict[str, Any]:
    """
    Cached version of file loading with optional memoization.
    
    Args:
        file_path (str): Full path to the file
    
    Returns:
        Dict[str, Any]: Loaded data
    """
    entries = {}
    try:
        with open(file_path, 'r', encoding=config.DATA_LOADER_CONFIG['encoding']) as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                parts = line.split('=') if '=' in line else line.split('\t')
                if len(parts) >= 2:
                    key, value = parts[0], parts[1]
                    entries[key] = value

    except FileNotFoundError:
        logger.error(f"File not found: {file_path}")
        raise DataLoadError(f"File not found: {file_path}")
    except Exception as e:
        logger.error(f"Error loading {file_path}: {e}")
        raise DataLoadError(f"Error loading {file_path}: {e}")

    return entries

class DataLoader:
    """
    Advanced data loader with caching, validation, and refresh mechanisms.
    """
    
    def __init__(self, 
                 data_dir: Optional[str] = None, 
                 required_files: Optional[List[str]] = None,
                 refresh_interval: timedelta = timedelta(hours=24)):
        """
        Initialize the DataLoader.
        
        Args:
            data_dir (Optional[str]): Custom data directory
            required_files (Optional[List[str]]): Custom list of required files
            refresh_interval (timedelta): Interval for automatic data refresh
        """
        # Get the absolute path of the QTEngine directory
        self.qt_engine_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        
        # Set data directory relative to QTEngine directory if not provided
        if data_dir is None:
            data_dir = os.path.join(self.qt_engine_dir, 'data')
        
        self.data_dir = data_dir
        self.required_files = required_files or [
            'Names2.txt', 'Names.txt', 'VietPhrase.txt', 'ChinesePhienAmWords.txt'
        ]
        self.refresh_interval = refresh_interval
        self.last_load_time = None
        self.loaded_data = None
        
    @retry_on_failure()
    def load_data(self) -> Tuple[Trie, Trie, Trie, Dict[str, str], Dict[str, Any]]:
        """
        Load data from various files into Trie structures and dictionaries.
        
        Returns:
            Tuple containing loaded data structures and loading information
        """
        # Check if data needs refreshing
        if (self.loaded_data is not None and 
            self.last_load_time is not None and 
            datetime.now() - self.last_load_time < self.refresh_interval):
            return self.loaded_data
        
        loading_info: Dict[str, Any] = {'files_loaded': [], 'load_timestamp': datetime.now()}
        
        try:
            # Construct full file paths
            file_paths = {
                'names2': os.path.join(self.data_dir, 'Names2.txt'),
                'names': os.path.join(self.data_dir, 'Names.txt'),
                'viet_phrase': os.path.join(self.data_dir, 'VietPhrase.txt'),
                'chinese_phien_am': os.path.join(self.data_dir, 'ChinesePhienAmWords.txt')
            }
            
            # Load data with validation, making Names2.txt optional
            names2_data = {}
            names2_trie = Trie()
            if os.path.exists(file_paths['names2']):
                names2_data = load_file_cached(file_paths['names2'])
                if DataValidator.validate_dictionary(names2_data):
                    for key in names2_data:
                        names2_trie.insert(key, names2_data[key])
                    if not DataValidator.validate_trie(names2_trie):
                        logger.warning("Names2.txt Trie validation failed, ignoring the file")
                        names2_data = {}
                        names2_trie = Trie()
                else:
                    logger.warning("Names2.txt data validation failed, ignoring the file")
                    names2_data = {}
            
            names_data = load_file_cached(file_paths['names'])
            viet_phrase_data = load_file_cached(file_paths['viet_phrase'])
            chinese_phien_am_data = load_file_cached(file_paths['chinese_phien_am'])
            
            # Validate loaded data
            if not all([
                DataValidator.validate_dictionary(names_data),
                DataValidator.validate_dictionary(viet_phrase_data),
                DataValidator.validate_dictionary(chinese_phien_am_data)
            ]):
                raise DataLoadError("Data validation failed")
            
            # Create Trie structures
            names_trie = Trie()
            viet_phrase_trie = Trie()
            
            for key in names_data:
                names_trie.insert(key, names_data[key])
            for key in viet_phrase_data:
                viet_phrase_trie.insert(key, viet_phrase_data[key])
            
            # Validate Trie structures
            if not all([
                DataValidator.validate_trie(names_trie),
                DataValidator.validate_trie(viet_phrase_trie)
            ]):
                raise DataLoadError("Trie validation failed")
            
            # Update loading information
            loading_info['files_loaded'] = [name for name, path in file_paths.items() if os.path.exists(path)]
            loading_info['file_sizes'] = {
                name: os.path.getsize(path) for name, path in file_paths.items() if os.path.exists(path)
            }
            
            # Cache the results
            self.loaded_data = (
                names2_trie, 
                names_trie, 
                viet_phrase_trie, 
                chinese_phien_am_data, 
                loading_info
            )
            self.last_load_time = datetime.now()
            
            return self.loaded_data
        
        except Exception as e:
            logger.error(f"Data loading failed: {e}")
            raise DataLoadError(f"Comprehensive data loading failed: {e}")

# Maintain backward compatibility with existing code
def load_data(
    data_dir: Optional[str] = None, 
    required_files: Optional[List[str]] = None
) -> Tuple[Trie, Trie, Trie, Dict[str, str], Dict[str, Any]]:
    """
    Backward-compatible load_data function.
    
    Args:
        data_dir (Optional[str]): Custom data directory
        required_files (Optional[List[str]]): Custom list of required files
    
    Returns:
        Tuple containing loaded data structures and loading information
    """
    loader = DataLoader(data_dir, required_files)
    return loader.load_data()


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\src\data_watcher.py
# ========================================

import os
import time
import logging
from typing import Dict, Callable, Optional, Any
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from src.QTEngine.src.data_loader import DataLoader, DataLoadError

logger = logging.getLogger(__name__)

class DataFileWatcher:
    """
    A sophisticated file watcher for data files with intelligent reloading.
    
    This class monitors specified data files and provides an efficient mechanism
    to reload data when files are modified, with minimal overhead.
    """
    
    def __init__(self, 
                 data_dir: str, 
                 reload_callback: Optional[Callable] = None,
                 check_interval: float = 1.0):
        """
        Initialize the DataFileWatcher.
        
        Args:
            data_dir (str): Directory containing data files to watch
            reload_callback (Optional[Callable]): Function to call when data is reloaded
            check_interval (float): Interval to check for file changes in seconds
        """
        self.data_dir = data_dir
        self.reload_callback = reload_callback
        self.check_interval = check_interval
        self.data_loader = DataLoader(data_dir=data_dir)
        
        # Track file modification times
        self.file_mtimes: Dict[str, float] = {}
        self._initialize_file_mtimes()
        self.observer = None
    
    def _initialize_file_mtimes(self):
        """
        Initialize modification times for all watched files.
        """
        for filename in self.data_loader.required_files:
            filepath = os.path.join(self.data_dir, filename)
            if os.path.exists(filepath):
                self.file_mtimes[filename] = os.path.getmtime(filepath)
    
    def check_and_reload(self) -> bool:
        """
        Check if any data files have been modified and reload if necessary.
        
        Returns:
            bool: True if data was reloaded, False otherwise
        """
        files_modified = False
        
        for filename in self.data_loader.required_files:
            filepath = os.path.join(self.data_dir, filename)
            
            if not os.path.exists(filepath):
                continue
            
            current_mtime = os.path.getmtime(filepath)
            
            # Check if file has been modified
            if filename not in self.file_mtimes or current_mtime != self.file_mtimes[filename]:
                logger.info(f"Detected changes in {filename}")
                self.file_mtimes[filename] = current_mtime
                files_modified = True
        
        # If any files were modified, reload data
        if files_modified:
            try:
                # Reload data
                reloaded_data = self.data_loader.load_data()
                
                # Call reload callback if provided
                if self.reload_callback:
                    self.reload_callback(reloaded_data)
                
                logger.info("Data successfully reloaded")
                return True
            except DataLoadError as e:
                logger.error(f"Failed to reload data: {e}")
                return False
        
        return False
    
    def start_watching(self, blocking: bool = False):
        """
        Start watching data files for changes.
        
        Args:
            blocking (bool): Whether to block the main thread
        """
        class DataFileHandler(FileSystemEventHandler):
            def __init__(self, watcher):
                self.watcher = watcher
            
            def on_modified(self, event):
                if event.is_directory:
                    return
                
                filename = os.path.basename(event.src_path)
                if filename in self.watcher.data_loader.required_files:
                    logger.info(f"File modified: {filename}")
                    self.watcher.check_and_reload()
        
        # Setup file system observer
        event_handler = DataFileHandler(self)
        self.observer = Observer()
        self.observer.schedule(event_handler, self.data_dir, recursive=False)
        self.observer.start()
        
        if blocking:
            try:
                while True:
                    time.sleep(self.check_interval)
                    self.check_and_reload()
            except KeyboardInterrupt:
                self.observer.stop()
            self.observer.join()
        
        return self.observer
    
    def stop(self):
        """
        Stop watching data files for changes.
        """
        if self.observer:
            self.observer.stop()
            self.observer.join()

def create_data_watcher(data_dir: str, 
                        reload_callback: Optional[Callable] = None) -> DataFileWatcher:
    """
    Convenience function to create and start a DataFileWatcher.
    
    Args:
        data_dir (str): Directory containing data files
        reload_callback (Optional[Callable]): Function to call on data reload
    
    Returns:
        DataFileWatcher: Configured and started file watcher
    """
    watcher = DataFileWatcher(data_dir, reload_callback)
    watcher.start_watching()
    return watcher


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\src\performance.py
# ========================================

import cProfile
import logging
from typing import Callable

def profile_function(func: Callable) -> Callable:
    """
    Decorator to profile a function's performance.

    Args:
        func (Callable): The function to be profiled.

    Returns:
        Callable: The wrapped function with profiling.
    """
    def wrapper(*args, **kwargs):
        pr = cProfile.Profile()
        pr.enable()
        result = func(*args, **kwargs)
        pr.disable()
        
        stats = pr.getstats()
        total_calls = sum(stat.callcount for stat in stats)
        total_time = sum(stat.totaltime for stat in stats)
        
        logging.info(f"Performance profile for {func.__name__}:")
        logging.info(f"Total function calls: {total_calls}")
        logging.info(f"Total time: {total_time:.6f} seconds")
        
        return result
    return wrapper


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\src\ReplaceChar.py
# ========================================

﻿SPECIAL_CHARS = {
"""        "０": "0",
        "１": "1",
        "２": "2",
        "３": "3",
        "４": "4",
        "５": "5",
        "６": "6",
        "７": "7",
        "８": "8",
        "９": "9",
        "Ｚ": "Z",
        "Ｙ": "Y",
        "Ｘ": "X",
        "Ｗ": "W",
        "Ｖ": "V",
        "Ｕ": "U",
        "Ｔ": "T",
        "Ｓ": "S",
        "Ｒ": "R",
        "Ｑ": "Q",
        "Ｐ": "P",
        "Ｏ": "O",
        "Ｎ": "N",
        "Ｍ": "M",
        "Ｌ": "L",
        "Ｋ": "K",
        "Ｊ": "J",
        "Ｉ": "I",
        "Ｈ": "H",
        "Ｇ": "G",
        "Ｆ": "F",
        "Ｅ": "E",
        "Ｄ": "D",
        "Ｃ": "C",
        "Ｂ": "B",
        "Ａ": "A",
        "ｚ": "z",
        "ｙ": "y",
        "ｘ": "x",
        "ｗ": "w",
        "ｖ": "v",
        "ｕ": "u",
        "ｔ": "t",
        "ｓ": "s",
        "ｒ": "r",
        "ｑ": "q",
        "ｐ": "p",
        "ｏ": "o",
        "ｎ": "n",
        "ｍ": "m",
        "ｌ": "l",
        "ｋ": "k",
        "ｊ": "j",
        "ｉ": "i",
        "ｈ": "h",
        "ｇ": "g",
        "ｆ": "f",
        "ｅ": "e",
        "ｄ": "d",
        "ｃ": "c",
        "ｂ": "b",
        "ａ": "a","""
        "＿": "_",
        "╴": "_",
        "’": "’",
        "》": "»",
        "｝": "}",
        "﹜": "}",
        "】": "]",
        "］": "]",
        "﹞": "]",
        "）": ")",
        "｠": ")",
        "〈": "<",
        "《": "«",
        "｛": "{",
        "﹛": "{",
        "【": "[",
        "［": "[",
        "﹝": "[",
        "（": "(",
        "｟": "(",
        "“": "“",
        "”": "”",
        "』": "”",
        "‘": "‘",
        "「": "‘",
        "℃": "℃",
        "°": "°",
        "￡": "￡",
        "＄": "$",
        "﹩": "$",
        "￥": "￥",
        "·": "·",
        "•": "·",
        "‧": "·",
        "・": "·",
        "﹖": "?",
        "？": "?",
        "﹗": "!",
        "！": "!",
        "～": "~",
        "﹀": "∨",
        "︿": "∧",
        "︳": "|",
        "｜": "|",
        "︱": "|",
        "≧": "≥",
        "≦": "≤",
        "≒": "≈",
        "＝": "=",
        "﹦": "=",
        "＞": ">",
        "﹥": ">",
        "＜": "<",
        "﹤": "<",
        "﹣": "-",
        "﹟": "#",
        "＾": "^",
        "‵": "`",
        "¨": "¨",
        "‥": "¨",
        "ˉ": "-",
        "。": ".",
        "，": ",",
        "､ ": ",",
        "、": ",",
        "」": "’",
        "『": "“",
        "：": ":",
        "；": ";",
        "､": ",",
        "┅": "...",
        "…": "...",
        "∶": ":",
}

# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\src\text_processing.py
# ========================================

from typing import List, Tuple, Dict, Optional
from src.QTEngine.models.trie import Trie
from .character_utils import replace_special_chars, LATIN_CHARS
import re
import logging

class Block:
    def __init__(self, original: str, translated: str, orig_start: int, trans_start: int):
        self.original = original
        self.translated = translated
        self.orig_start = orig_start
        self.orig_end = orig_start + len(original)
        self.trans_start = trans_start
        self.trans_end = trans_start + len(translated)

class TranslationMapping:
    def __init__(self):
        self.blocks: List[Block] = []
        self.original_to_block: Dict[str, List[Block]] = {}  # One original text might map to multiple blocks (duplicates)
        self.translated_to_block: Dict[str, List[Block]] = {}  # One translated text might map to multiple blocks
        self.current_original_pos = 0
        self.current_translated_pos = 0

    def add_block(self, original: str, translated: str):
        """Add a new block to the mapping."""
        block = Block(original, translated, self.current_original_pos, self.current_translated_pos)
        self.blocks.append(block)
        
        # Update mappings
        if original not in self.original_to_block:
            self.original_to_block[original] = []
        self.original_to_block[original].append(block)
        
        if translated not in self.translated_to_block:
            self.translated_to_block[translated] = []
        self.translated_to_block[translated].append(block)
        
        # Update positions
        self.current_original_pos = block.orig_end
        self.current_translated_pos = block.trans_end

    def get_translated_segment(self, original: str, position: Optional[int] = None) -> Optional[Tuple[str, int, int]]:
        """
        Get translated segment and its position for an original text segment.
        If position is provided, returns the block closest to that position.
        """
        blocks = self.original_to_block.get(original)
        if not blocks:
            return None
            
        if position is not None:
            # Find the block closest to the given position
            closest_block = min(blocks, key=lambda b: abs(b.orig_start - position))
            return (closest_block.translated, closest_block.trans_start, closest_block.trans_end)
        
        # If no position provided, return the first occurrence
        block = blocks[0]
        return (block.translated, block.trans_start, block.trans_end)

    def get_original_segment(self, translated: str, position: Optional[int] = None) -> Optional[Tuple[str, int, int]]:
        """
        Get original segment and its position for a translated text segment.
        If position is provided, returns the block closest to that position.
        """
        blocks = self.translated_to_block.get(translated)
        if not blocks:
            return None
            
        if position is not None:
            # Find the block closest to the given position
            closest_block = min(blocks, key=lambda b: abs(b.trans_start - position))
            return (closest_block.original, closest_block.orig_start, closest_block.orig_end)
        
        # If no position provided, return the first occurrence
        block = blocks[0]
        return (block.original, block.orig_start, block.orig_end)

def convert_to_sino_vietnamese(
    text: str, 
    names2: Trie, 
    names: Trie, 
    viet_phrase: Trie, 
    chinese_phien_am: Dict[str, str]
) -> Tuple[str, TranslationMapping]:
    """
    Convert Chinese text to Sino-Vietnamese using block-based mapping.

    Args:
        text (str): The input Chinese text.
        names2 (Trie): Trie containing Names2.txt data.
        names (Trie): Trie containing Names.txt data.
        viet_phrase (Trie): Trie containing VietPhrase.txt data.
        chinese_phien_am (Dict[str, str]): Dictionary containing ChinesePhienAmWords.txt data.

    Returns:
        Tuple[str, TranslationMapping]: The converted Sino-Vietnamese text and mapping information.
    """
    if not isinstance(text, str):
        raise ValueError(f"Input text must be a string, got {type(text)}")
    
    if not text:
        logging.warning("Empty input text provided")
        return "", TranslationMapping()
    
    # Validate Trie and dictionary inputs
    for name, obj in [('names2', names2), ('names', names), ('viet_phrase', viet_phrase)]:
        if not isinstance(obj, Trie):
            raise ValueError(f"{name} must be a Trie object")
    
    if not isinstance(chinese_phien_am, dict):
        raise ValueError("chinese_phien_am must be a dictionary")

    text = replace_special_chars(text)
    
    tokens = []
    mapping = TranslationMapping()
    i = 0
    
    while i < len(text):
        # Check for a sequence of Latin characters
        latin_start = i
        while i < len(text) and text[i] in LATIN_CHARS:
            i += 1
        if i > latin_start:
            latin_text = text[latin_start:i]
            tokens.append(latin_text)
            mapping.add_block(latin_text, latin_text)
            continue
        
        # Try Names2 first
        name2_match, value = names2.find_longest_prefix(text[i:])
        if name2_match and value is not None:
            translated = split_value(value)
            tokens.append(translated)
            mapping.add_block(name2_match, translated)
            i += len(name2_match)
            continue
        
        # Try Names
        name_match, value = names.find_longest_prefix(text[i:])
        if name_match and value is not None:
            translated = split_value(value)
            tokens.append(translated)
            mapping.add_block(name_match, translated)
            i += len(name_match)
            continue
        
        # Try VietPhrase
        viet_phrase_match, value = viet_phrase.find_longest_prefix(text[i:])
        if viet_phrase_match and value is not None:
            translated = split_value(value)
            tokens.append(translated)
            mapping.add_block(viet_phrase_match, translated)
            i += len(viet_phrase_match)
            continue
        
        # Try Chinese Phien Am Words
        if text[i:i+1] in chinese_phien_am:
            translated = chinese_phien_am[text[i:i+1]]
            tokens.append(translated)
            mapping.add_block(text[i:i+1], translated)
            i += 1
            continue
        
        # If no match found, add the character as is
        tokens.append(text[i])
        mapping.add_block(text[i], text[i])
        i += 1

    # Rephrase the tokens
    result = rephrase(tokens)

    # Apply regex transformations
    result = re.sub(r'([\[\“\‘])\s*(\w)', lambda m: m.group(1) + m.group(2).upper(), result)
    result = re.sub(r'\s+([”\’\]])', r'\1', result)
    result = re.sub(r'([?!⟨:«])\s+(\w)', lambda m: m.group(1) + ' ' + m.group(2).upper(), result)
    result = re.sub(r'\s+([;:?!.])', r'\1', result)
    result = re.sub(r'(?<!\.)\.(?!\.)\s+(\w)', lambda m: '. ' + m.group(1).upper(), result)
    
    return result, mapping

def split_value(value: str) -> str:
    """
    Split a value with multiple definitions and return the first non-empty definition.
    
    Args:
        value (str): Input value potentially containing multiple definitions.
    
    Returns:
        str: First non-empty definition of the value, or a space if empty.
    """
    if '=' in value:
        parts = value.split('=', 1)
        value = parts[1]
    
    split_parts = value.replace("|", "/").split("/")
    
    if not split_parts[0].strip():
        return ' '
    
    for part in split_parts:
        stripped_part = part.strip()
        if stripped_part:
            return stripped_part
    
    return value

def rephrase(tokens: List[str]) -> str:
    """
    Rephrase the tokens to form a properly formatted sentence.

    Args:
        tokens (List[str]): A list of tokens to be rephrased.

    Returns:
        str: The rephrased text.
    """
    non_word = set('"[{ ,!?;\'.')
    result = []
    upper = False
    last_token_empty = False

    for i, token in enumerate(tokens):
        if token.strip():  # Non-empty token
            if i == 0 or (not upper and token not in non_word):
                if result and not last_token_empty:
                    result.append(' ')
                if not token[0].isupper():  # Only capitalize if not already capitalized
                    token = token.capitalize()
                upper = True
            elif token not in non_word and not last_token_empty:
                result.append(' ')
            result.append(token)
            last_token_empty = False
        else:  # Empty or whitespace token
            result.append(token)  # Preserve the original whitespace
            last_token_empty = True

    text = ''.join(result)
    return text

def process_paragraph(
    paragraph: str, 
    names2: Trie, 
    names: Trie, 
    viet_phrase: Trie, 
    chinese_phien_am: Dict[str, str]
) -> Tuple[str, TranslationMapping]:
    """
    Process a single paragraph by converting it to Sino-Vietnamese.

    Args:
        paragraph (str): The input paragraph in Chinese.
        names2 (Trie): Trie containing Names2.txt data.
        names (Trie): Trie containing Names.txt data.
        viet_phrase (Trie): Trie containing VietPhrase.txt data.
        chinese_phien_am (Dict[str, str]): Dictionary containing ChinesePhienAmWords.txt data.

    Returns:
        Tuple[str, TranslationMapping]: The processed paragraph in Sino-Vietnamese and mapping information.
    """
    lines = paragraph.splitlines(keepends=True)
    result_lines = []
    mapping = TranslationMapping()
    
    current_orig_pos = 0
    current_trans_pos = 0
    
    for line in lines:
        leading_space = ''
        for char in line:
            if char.isspace():
                leading_space += char
            else:
                break
                
        content = line.lstrip()
        if content:
            converted, line_mapping = convert_to_sino_vietnamese(content, names2, names, viet_phrase, chinese_phien_am)
            result_lines.append(leading_space + converted)
            
            # Adjust positions for leading space
            space_offset = len(leading_space)
            
            # Update positions for this line's blocks
            for block in line_mapping.blocks:
                block.orig_start += current_orig_pos + space_offset
                block.orig_end += current_orig_pos + space_offset
                block.trans_start += current_trans_pos + space_offset
                block.trans_end += current_trans_pos + space_offset
                mapping.blocks.append(block)
                
                # Update the mapping dictionaries
                if block.original not in mapping.original_to_block:
                    mapping.original_to_block[block.original] = []
                mapping.original_to_block[block.original].append(block)
                
                if block.translated not in mapping.translated_to_block:
                    mapping.translated_to_block[block.translated] = []
                mapping.translated_to_block[block.translated].append(block)
            
            # Update positions for next line
            current_orig_pos += len(line)
            current_trans_pos += len(leading_space + converted)
        else:
            result_lines.append(line)
            # Update positions for empty lines
            current_orig_pos += len(line)
            current_trans_pos += len(line)
    
    return ''.join(result_lines), mapping

def preprocess_text(text: str) -> str:
    """
    Preprocess input text for translation.
    
    Args:
        text (str): Input text to preprocess
    Returns:
        str: Preprocessed text
    """
    text = re.sub(r'\s+', ' ', text).strip()
    text = text.lower()
    text = re.sub(r'[^\w\s]', '', text)
    return text

def process_paragraph_new(
    paragraph: str, 
    names2_trie: Dict[str, str], 
    names_trie: Dict[str, str], 
    viet_phrase_trie: Dict[str, str], 
    chinese_phien_am_data: Dict[str, str]
) -> Tuple[str, TranslationMapping]:
    """
    Process and translate a paragraph.
    
    Args:
        paragraph (str): Input paragraph
        names2_trie (Dict[str, str]): Names2 translation dictionary
        names_trie (Dict[str, str]): Names translation dictionary
        viet_phrase_trie (Dict[str, str]): VietPhrase translation dictionary
        chinese_phien_am_data (Dict[str, str]): Chinese Phien Am translation dictionary
    Returns:
        Tuple[str, TranslationMapping]: Translated paragraph and mapping information
    """
    preprocessed_text = preprocess_text(paragraph)
    
    translated_segments = []
    mapping = TranslationMapping()
    
    for segment in preprocessed_text.split():
        translation = (
            viet_phrase_trie.get(segment) or
            names_trie.get(segment) or
            names2_trie.get(segment) or
            segment
        )
        translated_segments.append(translation)
        mapping.add_mapping(segment, translation)
    
    return ' '.join(translated_segments), mapping

def convert_to_sino_vietnamese_new(text: str) -> str:
    """
    Fallback method to convert text to Sino-Vietnamese.
    
    Args:
        text (str): Input text
    Returns:
        str: Converted text
    """
    return text


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\src\translation_engine.py
# ========================================

from abc import ABC, abstractmethod
from typing import Dict, Optional, Any, Tuple
import logging
import os

from src.QTEngine.src.data_loader import DataLoader
from src.QTEngine.src.data_watcher import DataFileWatcher, create_data_watcher

logger = logging.getLogger(__name__)

class TranslationEngine(ABC):
    """
    Abstract base class for translation engines with dynamic data watching.
    Defines the core interface for translation functionality.
    """
    
    def __init__(self, 
                 data_loader: Optional[DataLoader] = None, 
                 config: Optional[Dict[str, Any]] = None,
                 data_dir: Optional[str] = None,
                 auto_watch: bool = True):
        """
        Initialize the translation engine with optional data watching.
        
        Args:
            data_loader: Optional custom data loader
            config: Optional configuration dictionary
            data_dir: Optional directory for data files
            auto_watch: Whether to automatically start file watching
        """
        self.config = config or {}
        self.data_loader = data_loader or DataLoader(data_dir=data_dir)
        self.data_dir = data_dir or self.data_loader.data_dir
        
        # Initial data load
        self.data = self.data_loader.load_data()
        
        # Setup file watcher
        self.data_watcher = None
        if auto_watch:
            self.start_data_watching()
    
    def start_data_watching(self):
        """
        Start watching data files for changes.
        """
        try:
            self.data_watcher = create_data_watcher(
                data_dir=self.data_dir, 
                reload_callback=self._on_data_reload
            )
            logger.info(f"Started watching data files in {self.data_dir}")
        except Exception as e:
            logger.error(f"Failed to start data watching: {e}")
    
    def _on_data_reload(self, new_data: Tuple):
        """
        Internal method to handle data reloading.
        
        Args:
            new_data: Newly loaded data tuple
        """
        try:
            logger.info("Reloading translation data")
            self.data = new_data
            self.refresh_data()
        except Exception as e:
            logger.error(f"Error during data reload: {e}")
    
    @abstractmethod
    def translate(self, text: str) -> str:
        """
        Translate the input text.
        
        Args:
            text (str): Input text to translate
        
        Returns:
            str: Translated text
        """
        raise NotImplementedError("Subclasses must implement translation method")
    
    @abstractmethod
    def validate_translation(self, original: str, translated: str) -> bool:
        """
        Validate the quality of translation.
        
        Args:
            original (str): Original text
            translated (str): Translated text
        
        Returns:
            bool: Whether the translation meets quality standards
        """
        raise NotImplementedError("Subclasses must implement translation validation")
    
    def refresh_data(self):
        """
        Optional method to refresh translation data.
        Can be overridden by subclasses to perform custom actions on data reload.
        """
        pass
    
    def get_translation_metadata(self) -> Dict[str, Any]:
        """
        Retrieve metadata about the translation process.
        
        Returns:
            Dict[str, Any]: Translation metadata
        """
        return {
            'data_dir': self.data_dir,
            'watching_enabled': self.data_watcher is not None
        }
    
    def stop_data_watching(self):
        """
        Stop watching data files.
        """
        if self.data_watcher:
            self.data_watcher.stop()
            logger.info("Stopped data file watching")


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\QTEngine\src\__init__.py
# ========================================

# QTEngine source package
from .character_utils import replace_special_chars, LATIN_CHARS
from .text_processing import (
    convert_to_sino_vietnamese, 
    rephrase, 
    process_paragraph
)
from .performance import profile_function
from .data_loader import load_data


# ========================================
# File: C:\Users\Zhu Xian\source\repos\ZXReader\src\utils\qt_utils.py
# ========================================

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QMessageBox, QDesktopWidget

# Define constants for easier use
HORIZONTAL = Qt.Orientation.Horizontal
VERTICAL = Qt.Orientation.Vertical
YES = QMessageBox.StandardButton.Yes
NO = QMessageBox.StandardButton.No

def center_window(window):
    """Centers the given window on the screen."""
    screen = QDesktopWidget().screenGeometry()
    size = window.geometry()
    window.move((screen.width() - size.width()) // 2, (screen.height() - size.height()) // 2)
